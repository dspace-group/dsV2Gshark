/* SPDX-License-Identifier: Apache-2.0 */
/*
 * Copyright (C) 2022 - 2023 chargebyte GmbH
 * Copyright (C) 2022 - 2023 Contributors to EVerest
 */

/*****************************************************
 *
 * @author
 * @version
 *
 * The Code is generated! Changes may be overwritten.
 *
 *****************************************************/

/**
  * @file iso20_CommonMessages_Decoder.c
  * @brief Description goes here
  *
  **/
#include <inttypes.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "exi_basetypes.h"
#include "exi_types_decoder.h"
#include "exi_basetypes_decoder.h"
#include "exi_error_codes.h"
#include "exi_header.h"
#include "iso20_CommonMessages_Datatypes.h"
#include "iso20_CommonMessages_Decoder.h"



static int decode_iso20_TransformType(exi_bitstream_t* stream, struct iso20_TransformType* TransformType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_TransformsType(exi_bitstream_t* stream, struct iso20_TransformsType* TransformsType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_DSAKeyValueType(exi_bitstream_t* stream, struct iso20_DSAKeyValueType* DSAKeyValueType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_X509IssuerSerialType(exi_bitstream_t* stream, struct iso20_X509IssuerSerialType* X509IssuerSerialType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_DigestMethodType(exi_bitstream_t* stream, struct iso20_DigestMethodType* DigestMethodType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_RSAKeyValueType(exi_bitstream_t* stream, struct iso20_RSAKeyValueType* RSAKeyValueType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso20_CanonicalizationMethodType* CanonicalizationMethodType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceLevelScheduleEntryType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleEntryType* PriceLevelScheduleEntryType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignatureMethodType(exi_bitstream_t* stream, struct iso20_SignatureMethodType* SignatureMethodType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_KeyValueType(exi_bitstream_t* stream, struct iso20_KeyValueType* KeyValueType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ReferenceType(exi_bitstream_t* stream, struct iso20_ReferenceType* ReferenceType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_RetrievalMethodType(exi_bitstream_t* stream, struct iso20_RetrievalMethodType* RetrievalMethodType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_X509DataType(exi_bitstream_t* stream, struct iso20_X509DataType* X509DataType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PGPDataType(exi_bitstream_t* stream, struct iso20_PGPDataType* PGPDataType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_RationalNumberType(exi_bitstream_t* stream, struct iso20_RationalNumberType* RationalNumberType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PowerScheduleEntryType(exi_bitstream_t* stream, struct iso20_PowerScheduleEntryType* PowerScheduleEntryType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPriceRuleType(exi_bitstream_t* stream, struct iso20_EVPriceRuleType* EVPriceRuleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPowerScheduleEntryType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleEntryType* EVPowerScheduleEntryType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPriceRuleStackType(exi_bitstream_t* stream, struct iso20_EVPriceRuleStackType* EVPriceRuleStackType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceRuleType(exi_bitstream_t* stream, struct iso20_PriceRuleType* PriceRuleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PowerScheduleEntryListType(exi_bitstream_t* stream, struct iso20_PowerScheduleEntryListType* PowerScheduleEntryListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_TaxRuleType(exi_bitstream_t* stream, struct iso20_TaxRuleType* TaxRuleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceRuleStackType(exi_bitstream_t* stream, struct iso20_PriceRuleStackType* PriceRuleStackType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AdditionalServiceType(exi_bitstream_t* stream, struct iso20_AdditionalServiceType* AdditionalServiceType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PowerScheduleType(exi_bitstream_t* stream, struct iso20_PowerScheduleType* PowerScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPowerScheduleEntryListType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleEntryListType* EVPowerScheduleEntryListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_OverstayRuleType(exi_bitstream_t* stream, struct iso20_OverstayRuleType* OverstayRuleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPriceRuleStackListType(exi_bitstream_t* stream, struct iso20_EVPriceRuleStackListType* EVPriceRuleStackListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SPKIDataType(exi_bitstream_t* stream, struct iso20_SPKIDataType* SPKIDataType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignedInfoType(exi_bitstream_t* stream, struct iso20_SignedInfoType* SignedInfoType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPowerScheduleType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleType* EVPowerScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignatureValueType(exi_bitstream_t* stream, struct iso20_SignatureValueType* SignatureValueType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SubCertificatesType(exi_bitstream_t* stream, struct iso20_SubCertificatesType* SubCertificatesType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ParameterType(exi_bitstream_t* stream, struct iso20_ParameterType* ParameterType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVAbsolutePriceScheduleType(exi_bitstream_t* stream, struct iso20_EVAbsolutePriceScheduleType* EVAbsolutePriceScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_DetailedCostType(exi_bitstream_t* stream, struct iso20_DetailedCostType* DetailedCostType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_KeyInfoType(exi_bitstream_t* stream, struct iso20_KeyInfoType* KeyInfoType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ObjectType(exi_bitstream_t* stream, struct iso20_ObjectType* ObjectType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceLevelScheduleEntryListType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleEntryListType* PriceLevelScheduleEntryListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_DetailedTaxType(exi_bitstream_t* stream, struct iso20_DetailedTaxType* DetailedTaxType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_TaxRuleListType(exi_bitstream_t* stream, struct iso20_TaxRuleListType* TaxRuleListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceRuleStackListType(exi_bitstream_t* stream, struct iso20_PriceRuleStackListType* PriceRuleStackListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_OverstayRuleListType(exi_bitstream_t* stream, struct iso20_OverstayRuleListType* OverstayRuleListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AdditionalServiceListType(exi_bitstream_t* stream, struct iso20_AdditionalServiceListType* AdditionalServiceListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceType(exi_bitstream_t* stream, struct iso20_ServiceType* ServiceType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ParameterSetType(exi_bitstream_t* stream, struct iso20_ParameterSetType* ParameterSetType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SupportedProvidersListType(exi_bitstream_t* stream, struct iso20_SupportedProvidersListType* SupportedProvidersListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ContractCertificateChainType(exi_bitstream_t* stream, struct iso20_ContractCertificateChainType* ContractCertificateChainType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Dynamic_EVPPTControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_EVPPTControlModeType* Dynamic_EVPPTControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_MeterInfoType(exi_bitstream_t* stream, struct iso20_MeterInfoType* MeterInfoType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignatureType(exi_bitstream_t* stream, struct iso20_SignatureType* SignatureType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Scheduled_EVPPTControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_EVPPTControlModeType* Scheduled_EVPPTControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ReceiptType(exi_bitstream_t* stream, struct iso20_ReceiptType* ReceiptType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AbsolutePriceScheduleType(exi_bitstream_t* stream, struct iso20_AbsolutePriceScheduleType* AbsolutePriceScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPowerProfileEntryListType(exi_bitstream_t* stream, struct iso20_EVPowerProfileEntryListType* EVPowerProfileEntryListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Dynamic_SMDTControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SMDTControlModeType* Dynamic_SMDTControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVEnergyOfferType(exi_bitstream_t* stream, struct iso20_EVEnergyOfferType* EVEnergyOfferType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PriceLevelScheduleType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleType* PriceLevelScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ChargingScheduleType(exi_bitstream_t* stream, struct iso20_ChargingScheduleType* ChargingScheduleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ScheduleTupleType(exi_bitstream_t* stream, struct iso20_ScheduleTupleType* ScheduleTupleType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Scheduled_SMDTControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SMDTControlModeType* Scheduled_SMDTControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_MessageHeaderType(exi_bitstream_t* stream, struct iso20_MessageHeaderType* MessageHeaderType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignaturePropertyType(exi_bitstream_t* stream, struct iso20_SignaturePropertyType* SignaturePropertyType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceIDListType(exi_bitstream_t* stream, struct iso20_ServiceIDListType* ServiceIDListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SelectedServiceType(exi_bitstream_t* stream, struct iso20_SelectedServiceType* SelectedServiceType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignedMeteringDataType(exi_bitstream_t* stream, struct iso20_SignedMeteringDataType* SignedMeteringDataType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignedCertificateChainType(exi_bitstream_t* stream, struct iso20_SignedCertificateChainType* SignedCertificateChainType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EIM_AReqAuthorizationModeType(exi_bitstream_t* stream, struct iso20_EIM_AReqAuthorizationModeType* EIM_AReqAuthorizationModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SelectedServiceListType(exi_bitstream_t* stream, struct iso20_SelectedServiceListType* SelectedServiceListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Dynamic_SEReqControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SEReqControlModeType* Dynamic_SEReqControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVSEStatusType(exi_bitstream_t* stream, struct iso20_EVSEStatusType* EVSEStatusType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ListOfRootCertificateIDsType(exi_bitstream_t* stream, struct iso20_ListOfRootCertificateIDsType* ListOfRootCertificateIDsType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PnC_AReqAuthorizationModeType(exi_bitstream_t* stream, struct iso20_PnC_AReqAuthorizationModeType* PnC_AReqAuthorizationModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceListType(exi_bitstream_t* stream, struct iso20_ServiceListType* ServiceListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceParameterListType(exi_bitstream_t* stream, struct iso20_ServiceParameterListType* ServiceParameterListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Scheduled_SEReqControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SEReqControlModeType* Scheduled_SEReqControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EVPowerProfileType(exi_bitstream_t* stream, struct iso20_EVPowerProfileType* EVPowerProfileType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CertificateChainType(exi_bitstream_t* stream, struct iso20_CertificateChainType* CertificateChainType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EIM_ASResAuthorizationModeType(exi_bitstream_t* stream, struct iso20_EIM_ASResAuthorizationModeType* EIM_ASResAuthorizationModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Dynamic_SEResControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SEResControlModeType* Dynamic_SEResControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_EMAIDListType(exi_bitstream_t* stream, struct iso20_EMAIDListType* EMAIDListType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignedInstallationDataType(exi_bitstream_t* stream, struct iso20_SignedInstallationDataType* SignedInstallationDataType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PnC_ASResAuthorizationModeType(exi_bitstream_t* stream, struct iso20_PnC_ASResAuthorizationModeType* PnC_ASResAuthorizationModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_Scheduled_SEResControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SEResControlModeType* Scheduled_SEResControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SessionSetupReqType(exi_bitstream_t* stream, struct iso20_SessionSetupReqType* SessionSetupReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SessionSetupResType(exi_bitstream_t* stream, struct iso20_SessionSetupResType* SessionSetupResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AuthorizationSetupReqType(exi_bitstream_t* stream, struct iso20_AuthorizationSetupReqType* AuthorizationSetupReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AuthorizationSetupResType(exi_bitstream_t* stream, struct iso20_AuthorizationSetupResType* AuthorizationSetupResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AuthorizationReqType(exi_bitstream_t* stream, struct iso20_AuthorizationReqType* AuthorizationReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_AuthorizationResType(exi_bitstream_t* stream, struct iso20_AuthorizationResType* AuthorizationResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceDiscoveryReqType(exi_bitstream_t* stream, struct iso20_ServiceDiscoveryReqType* ServiceDiscoveryReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceDiscoveryResType(exi_bitstream_t* stream, struct iso20_ServiceDiscoveryResType* ServiceDiscoveryResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceDetailReqType(exi_bitstream_t* stream, struct iso20_ServiceDetailReqType* ServiceDetailReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceDetailResType(exi_bitstream_t* stream, struct iso20_ServiceDetailResType* ServiceDetailResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceSelectionReqType(exi_bitstream_t* stream, struct iso20_ServiceSelectionReqType* ServiceSelectionReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ServiceSelectionResType(exi_bitstream_t* stream, struct iso20_ServiceSelectionResType* ServiceSelectionResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ScheduleExchangeReqType(exi_bitstream_t* stream, struct iso20_ScheduleExchangeReqType* ScheduleExchangeReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ScheduleExchangeResType(exi_bitstream_t* stream, struct iso20_ScheduleExchangeResType* ScheduleExchangeResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PowerDeliveryReqType(exi_bitstream_t* stream, struct iso20_PowerDeliveryReqType* PowerDeliveryReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_PowerDeliveryResType(exi_bitstream_t* stream, struct iso20_PowerDeliveryResType* PowerDeliveryResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_MeteringConfirmationReqType(exi_bitstream_t* stream, struct iso20_MeteringConfirmationReqType* MeteringConfirmationReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_MeteringConfirmationResType(exi_bitstream_t* stream, struct iso20_MeteringConfirmationResType* MeteringConfirmationResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SessionStopReqType(exi_bitstream_t* stream, struct iso20_SessionStopReqType* SessionStopReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SessionStopResType(exi_bitstream_t* stream, struct iso20_SessionStopResType* SessionStopResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CertificateInstallationReqType(exi_bitstream_t* stream, struct iso20_CertificateInstallationReqType* CertificateInstallationReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CertificateInstallationResType(exi_bitstream_t* stream, struct iso20_CertificateInstallationResType* CertificateInstallationResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_VehicleCheckInReqType(exi_bitstream_t* stream, struct iso20_VehicleCheckInReqType* VehicleCheckInReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_VehicleCheckInResType(exi_bitstream_t* stream, struct iso20_VehicleCheckInResType* VehicleCheckInResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_VehicleCheckOutReqType(exi_bitstream_t* stream, struct iso20_VehicleCheckOutReqType* VehicleCheckOutReqType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_VehicleCheckOutResType(exi_bitstream_t* stream, struct iso20_VehicleCheckOutResType* VehicleCheckOutResType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_CLReqControlModeType* CLReqControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_CLResControlModeType(exi_bitstream_t* stream, struct iso20_CLResControlModeType* CLResControlModeType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_ManifestType(exi_bitstream_t* stream, struct iso20_ManifestType* ManifestType, char* xmlOut, size_t xmlOut_size);
static int decode_iso20_SignaturePropertiesType(exi_bitstream_t* stream, struct iso20_SignaturePropertiesType* SignaturePropertiesType, char* xmlOut, size_t xmlOut_size);

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transform; type={http://www.w3.org/2000/09/xmldsig#}TransformType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1); XPath, string (0, 1);
static int decode_iso20_TransformType(exi_bitstream_t* stream, struct iso20_TransformType* TransformType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 0;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_TransformType(TransformType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 0:
            // Grammar: ID=0; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=1
                    if(strlen(xmlOut) + 9 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &TransformType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (TransformType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            TransformType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, TransformType->Algorithm.charactersLen, TransformType->Algorithm.characters, iso20_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + TransformType->Algorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < TransformType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(TransformType->Algorithm.characters[i]))
                                {
                                    TransformType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, TransformType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 1;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 1:
            // Grammar: ID=1; read/write bits=3; START (XPath), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (XPath, string (string)); next=2
                    if(strlen(xmlOut) + 41 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}XPath");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}XPath");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &TransformType->XPath.charactersLen);
                            if (error == 0)
                            {
                                if (TransformType->XPath.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    TransformType->XPath.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, TransformType->XPath.charactersLen, TransformType->XPath.characters, iso20_XPath_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + TransformType->XPath.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < TransformType->XPath.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(TransformType->XPath.characters[i]))
                                        {
                                            TransformType->XPath.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, TransformType->XPath.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                TransformType->XPath_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 41 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}XPath>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &TransformType->ANY.bytesLen, &TransformType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((TransformType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < TransformType->ANY.bytesLen;) {
                            uint32_t octet_a = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < TransformType->ANY.bytesLen ? (unsigned char) TransformType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[TransformType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        TransformType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Transforms; type={http://www.w3.org/2000/09/xmldsig#}TransformsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Transform, TransformType (1, 1) (original max unbounded);
static int decode_iso20_TransformsType(exi_bitstream_t* stream, struct iso20_TransformsType* TransformsType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 4;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_TransformsType(TransformsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 4:
            // Grammar: ID=4; read/write bits=1; START (Transform)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Transform, TransformType (TransformType)); next=5
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    // decode: element
                    error = decode_iso20_TransformType(stream, &TransformsType->Transform, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 5;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transform>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 5:
            // Grammar: ID=5; read/write bits=2; START (Transform), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Transform, TransformType (TransformType)); next=2
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transform");
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transform>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}DSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: P, CryptoBinary (0, 1) (was 1, 1) (seq. ['P', 'Q']); Q, CryptoBinary (0, 1) (was 1, 1) (seq. ['P', 'Q']); G, CryptoBinary (0, 1); Y, CryptoBinary (1, 1); J, CryptoBinary (0, 1); Seed, CryptoBinary (0, 1) (was 1, 1) (seq. ['Seed', 'PgenCounter']); PgenCounter, CryptoBinary (0, 1) (was 1, 1) (seq. ['Seed', 'PgenCounter']);
static int decode_iso20_DSAKeyValueType(exi_bitstream_t* stream, struct iso20_DSAKeyValueType* DSAKeyValueType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 6;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_DSAKeyValueType(DSAKeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 6:
            // Grammar: ID=6; read/write bits=2; START (P), START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (P, CryptoBinary (base64Binary)); next=7
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}P");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}P");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->P.bytesLen, &DSAKeyValueType->P.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->P.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->P.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->P.bytesLen ? (unsigned char) DSAKeyValueType->P.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->P.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->P_isUsed = 1u;
                        grammar_id = 7;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}P>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (G, CryptoBinary (base64Binary)); next=9
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}G");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}G");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->G.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->G.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->G.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 9;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}G>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 10;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 7:
            // Grammar: ID=7; read/write bits=1; START (Q)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Q, CryptoBinary (base64Binary)); next=8
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Q");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Q");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Q.bytesLen, &DSAKeyValueType->Q.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Q.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Q.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Q.bytesLen ? (unsigned char) DSAKeyValueType->Q.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Q.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Q_isUsed = 1u;
                        grammar_id = 8;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Q>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 8:
            // Grammar: ID=8; read/write bits=2; START (G), START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (G, CryptoBinary (base64Binary)); next=9
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}G");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}G");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->G.bytesLen, &DSAKeyValueType->G.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->G.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->G.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->G.bytesLen ? (unsigned char) DSAKeyValueType->G.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->G.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->G_isUsed = 1u;
                        grammar_id = 9;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}G>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 10;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 9:
            // Grammar: ID=9; read/write bits=1; START (Y)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Y, CryptoBinary (base64Binary)); next=10
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Y");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Y");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Y.bytesLen, &DSAKeyValueType->Y.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Y.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Y.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Y.bytesLen ? (unsigned char) DSAKeyValueType->Y.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Y.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 10;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Y>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 10:
            // Grammar: ID=10; read/write bits=2; START (J), START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (J, CryptoBinary (base64Binary)); next=11
                    if(strlen(xmlOut) + 37 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}J");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}J");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->J.bytesLen, &DSAKeyValueType->J.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->J.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->J.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->J.bytesLen ? (unsigned char) DSAKeyValueType->J.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->J.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->J_isUsed = 1u;
                        grammar_id = 11;
                    }




                    if(strlen(xmlOut) + 37 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}J>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=12
                    if(strlen(xmlOut) + 40 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Seed.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Seed.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Seed.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 12;
                    }




                    if(strlen(xmlOut) + 40 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Seed>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 11:
            // Grammar: ID=11; read/write bits=2; START (Seed), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Seed, CryptoBinary (base64Binary)); next=12
                    if(strlen(xmlOut) + 40 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Seed");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->Seed.bytesLen, &DSAKeyValueType->Seed.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->Seed.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->Seed.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->Seed.bytesLen ? (unsigned char) DSAKeyValueType->Seed.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->Seed.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->Seed_isUsed = 1u;
                        grammar_id = 12;
                    }




                    if(strlen(xmlOut) + 40 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Seed>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 12:
            // Grammar: ID=12; read/write bits=2; START (PgenCounter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PgenCounter, CryptoBinary (base64Binary)); next=2
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PgenCounter");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PgenCounter");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DSAKeyValueType->PgenCounter.bytesLen, &DSAKeyValueType->PgenCounter.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DSAKeyValueType->PgenCounter.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DSAKeyValueType->PgenCounter.bytesLen;) {
                            uint32_t octet_a = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            uint32_t octet_b = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            uint32_t octet_c = i < DSAKeyValueType->PgenCounter.bytesLen ? (unsigned char) DSAKeyValueType->PgenCounter.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DSAKeyValueType->PgenCounter.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DSAKeyValueType->PgenCounter_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PgenCounter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial; type={http://www.w3.org/2000/09/xmldsig#}X509IssuerSerialType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerName, string (1, 1); X509SerialNumber, integer (1, 1);
static int decode_iso20_X509IssuerSerialType(exi_bitstream_t* stream, struct iso20_X509IssuerSerialType* X509IssuerSerialType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 13;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_X509IssuerSerialType(X509IssuerSerialType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 13:
            // Grammar: ID=13; read/write bits=1; START (X509IssuerName)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (X509IssuerName, string (string)); next=14
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509IssuerName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509IssuerName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509IssuerSerialType->X509IssuerName.charactersLen);
                            if (error == 0)
                            {
                                if (X509IssuerSerialType->X509IssuerName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509IssuerSerialType->X509IssuerName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509IssuerSerialType->X509IssuerName.charactersLen, X509IssuerSerialType->X509IssuerName.characters, iso20_X509IssuerName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + X509IssuerSerialType->X509IssuerName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < X509IssuerSerialType->X509IssuerName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(X509IssuerSerialType->X509IssuerName.characters[i]))
                                        {
                                            X509IssuerSerialType->X509IssuerName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, X509IssuerSerialType->X509IssuerName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 14;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509IssuerName>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 14:
            // Grammar: ID=14; read/write bits=1; START (X509SerialNumber)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (X509SerialNumber, integer (decimal)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber");
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &X509IssuerSerialType->X509SerialNumber);
                        if (error == 0)
                        {
                            uint8_t* realInteger = X509IssuerSerialType->X509SerialNumber.data.octets;
                            size_t realInteger_size = X509IssuerSerialType->X509SerialNumber.data.octets_count;
                            char asHex[128] = "";
                            if(strlen(xmlOut) + 128 + 3 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            char* ahPtr = &asHex[0];
                            uint8_t* contentPtr = &realInteger[0];
                            if(realInteger_size * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                            while(realInteger_size--) {
                              sprintf(ahPtr, "%02X", *contentPtr);
                              ahPtr += 2;
                              ++contentPtr;
                            }
                            *ahPtr = 0;
                            strcat(xmlOut, ">0x");
                            strcat(xmlOut, asHex);
                            grammar_id = 2;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}DigestMethod; type={http://www.w3.org/2000/09/xmldsig#}DigestMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_DigestMethodType(exi_bitstream_t* stream, struct iso20_DigestMethodType* DigestMethodType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 15;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_DigestMethodType(DigestMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 15:
            // Grammar: ID=15; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=16
                    if(strlen(xmlOut) + 9 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &DigestMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (DigestMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            DigestMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, DigestMethodType->Algorithm.charactersLen, DigestMethodType->Algorithm.characters, iso20_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + DigestMethodType->Algorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < DigestMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(DigestMethodType->Algorithm.characters[i]))
                                {
                                    DigestMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, DigestMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 16;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 16:
            // Grammar: ID=16; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &DigestMethodType->ANY.bytesLen, &DigestMethodType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((DigestMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < DigestMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < DigestMethodType->ANY.bytesLen ? (unsigned char) DigestMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[DigestMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        DigestMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RSAKeyValue; type={http://www.w3.org/2000/09/xmldsig#}RSAKeyValueType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Modulus, CryptoBinary (1, 1); Exponent, CryptoBinary (1, 1);
static int decode_iso20_RSAKeyValueType(exi_bitstream_t* stream, struct iso20_RSAKeyValueType* RSAKeyValueType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 17;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_RSAKeyValueType(RSAKeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 17:
            // Grammar: ID=17; read/write bits=1; START (Modulus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Modulus, CryptoBinary (base64Binary)); next=18
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Modulus");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Modulus");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Modulus.bytesLen, &RSAKeyValueType->Modulus.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((RSAKeyValueType->Modulus.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < RSAKeyValueType->Modulus.bytesLen;) {
                            uint32_t octet_a = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            uint32_t octet_b = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            uint32_t octet_c = i < RSAKeyValueType->Modulus.bytesLen ? (unsigned char) RSAKeyValueType->Modulus.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[RSAKeyValueType->Modulus.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 18;
                    }




                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Modulus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 18:
            // Grammar: ID=18; read/write bits=1; START (Exponent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Exponent, CryptoBinary (base64Binary)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Exponent");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Exponent");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &RSAKeyValueType->Exponent.bytesLen, &RSAKeyValueType->Exponent.bytes[0], iso20_CryptoBinary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((RSAKeyValueType->Exponent.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < RSAKeyValueType->Exponent.bytesLen;) {
                            uint32_t octet_a = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            uint32_t octet_b = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            uint32_t octet_c = i < RSAKeyValueType->Exponent.bytesLen ? (unsigned char) RSAKeyValueType->Exponent.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[RSAKeyValueType->Exponent.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Exponent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod; type={http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_CanonicalizationMethodType(exi_bitstream_t* stream, struct iso20_CanonicalizationMethodType* CanonicalizationMethodType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 19;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_CanonicalizationMethodType(CanonicalizationMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 19:
            // Grammar: ID=19; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=20
                    if(strlen(xmlOut) + 9 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &CanonicalizationMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (CanonicalizationMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            CanonicalizationMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, CanonicalizationMethodType->Algorithm.charactersLen, CanonicalizationMethodType->Algorithm.characters, iso20_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + CanonicalizationMethodType->Algorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < CanonicalizationMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(CanonicalizationMethodType->Algorithm.characters[i]))
                                {
                                    CanonicalizationMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, CanonicalizationMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 20;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 20:
            // Grammar: ID=20; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CanonicalizationMethodType->ANY.bytesLen, &CanonicalizationMethodType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CanonicalizationMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CanonicalizationMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < CanonicalizationMethodType->ANY.bytesLen ? (unsigned char) CanonicalizationMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CanonicalizationMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        CanonicalizationMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntryType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Duration, unsignedInt (1, 1); PriceLevel, unsignedByte (1, 1);
static int decode_iso20_PriceLevelScheduleEntryType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleEntryType* PriceLevelScheduleEntryType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 21;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceLevelScheduleEntryType(PriceLevelScheduleEntryType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 21:
            // Grammar: ID=21; read/write bits=1; START (Duration)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Duration, unsignedInt (unsignedLong)); next=22
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PriceLevelScheduleEntryType->Duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceLevelScheduleEntryType->Duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 22;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Duration>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 22:
            // Grammar: ID=22; read/write bits=1; START (PriceLevel)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceLevel, unsignedByte (unsignedShort)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevel");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevel");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceLevelScheduleEntryType->PriceLevel = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceLevelScheduleEntryType->PriceLevel);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevel>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureMethod; type={http://www.w3.org/2000/09/xmldsig#}SignatureMethodType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Algorithm, anyURI (1, 1); HMACOutputLength, HMACOutputLengthType (0, 1); ANY, anyType (0, 1);
static int decode_iso20_SignatureMethodType(exi_bitstream_t* stream, struct iso20_SignatureMethodType* SignatureMethodType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 23;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignatureMethodType(SignatureMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 23:
            // Grammar: ID=23; read/write bits=1; START (Algorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Algorithm, anyURI (anyURI)); next=24
                    if(strlen(xmlOut) + 9 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Algorithm");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureMethodType->Algorithm.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureMethodType->Algorithm.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureMethodType->Algorithm.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureMethodType->Algorithm.charactersLen, SignatureMethodType->Algorithm.characters, iso20_Algorithm_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignatureMethodType->Algorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignatureMethodType->Algorithm.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureMethodType->Algorithm.characters[i]))
                                {
                                    SignatureMethodType->Algorithm.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureMethodType->Algorithm.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 24;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 24:
            // Grammar: ID=24; read/write bits=3; START (HMACOutputLength), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (HMACOutputLength, HMACOutputLengthType (integer)); next=25
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength");
                    // decode: signed
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_signed(stream, &SignatureMethodType->HMACOutputLength);
                        if (error == 0)
                        {
                            uint8_t* realInteger = SignatureMethodType->HMACOutputLength.data.octets;
                            size_t realInteger_size = SignatureMethodType->HMACOutputLength.data.octets_count;
                            char asHex[128] = "";
                            if(strlen(xmlOut) + 128 + 3 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            char* ahPtr = &asHex[0];
                            uint8_t* contentPtr = &realInteger[0];
                            if(realInteger_size * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                            while(realInteger_size--) {
                              sprintf(ahPtr, "%02X", *contentPtr);
                              ahPtr += 2;
                              ++contentPtr;
                            }
                            *ahPtr = 0;
                            strcat(xmlOut, ">0x");
                            strcat(xmlOut, asHex);
                            SignatureMethodType->HMACOutputLength_isUsed = 1u;
                            grammar_id = 25;
                        }
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}HMACOutputLength>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 25:
            // Grammar: ID=25; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignatureMethodType->ANY.bytesLen, &SignatureMethodType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureMethodType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureMethodType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureMethodType->ANY.bytesLen ? (unsigned char) SignatureMethodType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureMethodType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignatureMethodType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyValue; type={http://www.w3.org/2000/09/xmldsig#}KeyValueType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: DSAKeyValue, DSAKeyValueType (0, 1); RSAKeyValue, RSAKeyValueType (0, 1); ANY, anyType (0, 1);
static int decode_iso20_KeyValueType(exi_bitstream_t* stream, struct iso20_KeyValueType* KeyValueType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 26;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_KeyValueType(KeyValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 26:
            // Grammar: ID=26; read/write bits=2; START (DSAKeyValue), START (RSAKeyValue), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DSAKeyValue, DSAKeyValueType (DSAKeyValueType)); next=2
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue");
                    // decode: element
                    error = decode_iso20_DSAKeyValueType(stream, &KeyValueType->DSAKeyValue, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyValueType->DSAKeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (RSAKeyValue, RSAKeyValueType (RSAKeyValueType)); next=2
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue");
                    // decode: element
                    error = decode_iso20_RSAKeyValueType(stream, &KeyValueType->RSAKeyValue, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyValueType->RSAKeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyValueType->ANY.bytesLen, &KeyValueType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyValueType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyValueType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyValueType->ANY.bytesLen ? (unsigned char) KeyValueType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyValueType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyValueType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Reference; type={http://www.w3.org/2000/09/xmldsig#}ReferenceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1); DigestMethod, DigestMethodType (1, 1); DigestValue, DigestValueType (1, 1);
static int decode_iso20_ReferenceType(exi_bitstream_t* stream, struct iso20_ReferenceType* ReferenceType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 27;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ReferenceType(ReferenceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 27:
            // Grammar: ID=27; read/write bits=3; START (Id), START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=28
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Id.charactersLen, ReferenceType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Id.characters[i]))
                                {
                                    ReferenceType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Id_isUsed = 1u;
                    grammar_id = 28;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=29
                    if(strlen(xmlOut) + 4 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->Type.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Type.characters[i]))
                                {
                                    ReferenceType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 29;

                    }
                    break;
                case 2:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=30
                    if(strlen(xmlOut) + 3 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->URI.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 30;

                    }
                    break;
                case 3:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=31
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &ReferenceType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 31;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=32
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso20_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 32;
                    }


                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 28:
            // Grammar: ID=28; read/write bits=3; START (Type), START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=29
                    if(strlen(xmlOut) + 4 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->Type.charactersLen, ReferenceType->Type.characters, iso20_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->Type.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->Type.characters[i]))
                                {
                                    ReferenceType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->Type_isUsed = 1u;
                    grammar_id = 29;

                    }
                    break;
                case 1:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=30
                    if(strlen(xmlOut) + 3 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->URI.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 30;

                    }
                    break;
                case 2:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=31
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &ReferenceType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 31;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=32
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso20_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 32;
                    }


                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 29:
            // Grammar: ID=29; read/write bits=2; START (URI), START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=30
                    if(strlen(xmlOut) + 3 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ReferenceType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (ReferenceType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ReferenceType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ReferenceType->URI.charactersLen, ReferenceType->URI.characters, iso20_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ReferenceType->URI.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ReferenceType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ReferenceType->URI.characters[i]))
                                {
                                    ReferenceType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ReferenceType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ReferenceType->URI_isUsed = 1u;
                    grammar_id = 30;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=31
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &ReferenceType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 31;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=32
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso20_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 32;
                    }


                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 30:
            // Grammar: ID=30; read/write bits=2; START (Transforms), START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=31
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &ReferenceType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReferenceType->Transforms_isUsed = 1u;
                        grammar_id = 31;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=32
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso20_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 32;
                    }


                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 31:
            // Grammar: ID=31; read/write bits=1; START (DigestMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DigestMethod, DigestMethodType (DigestMethodType)); next=32
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestMethod");
                    // decode: element
                    error = decode_iso20_DigestMethodType(stream, &ReferenceType->DigestMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 32;
                    }


                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 32:
            // Grammar: ID=32; read/write bits=1; START (DigestValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DigestValue, DigestValueType (base64Binary)); next=2
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}DigestValue");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ReferenceType->DigestValue.bytesLen, &ReferenceType->DigestValue.bytes[0], iso20_DigestValueType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ReferenceType->DigestValue.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ReferenceType->DigestValue.bytesLen;) {
                            uint32_t octet_a = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            uint32_t octet_b = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            uint32_t octet_c = i < ReferenceType->DigestValue.bytesLen ? (unsigned char) ReferenceType->DigestValue.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ReferenceType->DigestValue.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}RetrievalMethod; type={http://www.w3.org/2000/09/xmldsig#}RetrievalMethodType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Type, anyURI (0, 1); URI, anyURI (0, 1); Transforms, TransformsType (0, 1);
static int decode_iso20_RetrievalMethodType(exi_bitstream_t* stream, struct iso20_RetrievalMethodType* RetrievalMethodType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 33;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_RetrievalMethodType(RetrievalMethodType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 33:
            // Grammar: ID=33; read/write bits=3; START (Type), START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Type, anyURI (anyURI)); next=34
                    if(strlen(xmlOut) + 4 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Type");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->Type.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->Type.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->Type.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->Type.charactersLen, RetrievalMethodType->Type.characters, iso20_Type_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + RetrievalMethodType->Type.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < RetrievalMethodType->Type.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->Type.characters[i]))
                                {
                                    RetrievalMethodType->Type.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->Type.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->Type_isUsed = 1u;
                    grammar_id = 34;

                    }
                    break;
                case 1:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=35
                    if(strlen(xmlOut) + 3 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + RetrievalMethodType->URI.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < RetrievalMethodType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->URI.characters[i]))
                                {
                                    RetrievalMethodType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 35;

                    }
                    break;
                case 2:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 34:
            // Grammar: ID=34; read/write bits=2; START (URI), START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (URI, anyURI (anyURI)); next=35
                    if(strlen(xmlOut) + 3 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " URI");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &RetrievalMethodType->URI.charactersLen);
                    if (error == 0)
                    {
                        if (RetrievalMethodType->URI.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            RetrievalMethodType->URI.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, RetrievalMethodType->URI.charactersLen, RetrievalMethodType->URI.characters, iso20_URI_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + RetrievalMethodType->URI.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < RetrievalMethodType->URI.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(RetrievalMethodType->URI.characters[i]))
                                {
                                    RetrievalMethodType->URI.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, RetrievalMethodType->URI.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    RetrievalMethodType->URI_isUsed = 1u;
                    grammar_id = 35;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 35:
            // Grammar: ID=35; read/write bits=2; START (Transforms), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Transforms, TransformsType (TransformsType)); next=2
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Transforms");
                    // decode: element
                    error = decode_iso20_TransformsType(stream, &RetrievalMethodType->Transforms, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        RetrievalMethodType->Transforms_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}X509Data; type={http://www.w3.org/2000/09/xmldsig#}X509DataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: X509IssuerSerial, X509IssuerSerialType (0, 1); X509SKI, base64Binary (0, 1); X509SubjectName, string (0, 1); X509Certificate, base64Binary (0, 1); X509CRL, base64Binary (0, 1); ANY, anyType (0, 1);
static int decode_iso20_X509DataType(exi_bitstream_t* stream, struct iso20_X509DataType* X509DataType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 36;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_X509DataType(X509DataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 36:
            // Grammar: ID=36; read/write bits=3; START (X509IssuerSerial), START (X509SKI), START (X509SubjectName), START (X509Certificate), START (X509CRL), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (X509IssuerSerial, X509IssuerSerialType (X509IssuerSerialType)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial");
                    // decode: element
                    error = decode_iso20_X509IssuerSerialType(stream, &X509DataType->X509IssuerSerial, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        X509DataType->X509IssuerSerial_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (X509SKI, base64Binary (base64Binary)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SKI");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SKI");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509SKI.bytesLen, &X509DataType->X509SKI.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509SKI.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509SKI.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509SKI.bytesLen ? (unsigned char) X509DataType->X509SKI.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509SKI.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509SKI_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SKI>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (X509SubjectName, string (string)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509SubjectName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509SubjectName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &X509DataType->X509SubjectName.charactersLen);
                            if (error == 0)
                            {
                                if (X509DataType->X509SubjectName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    X509DataType->X509SubjectName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, X509DataType->X509SubjectName.charactersLen, X509DataType->X509SubjectName.characters, iso20_X509SubjectName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + X509DataType->X509SubjectName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < X509DataType->X509SubjectName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(X509DataType->X509SubjectName.characters[i]))
                                        {
                                            X509DataType->X509SubjectName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, X509DataType->X509SubjectName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                X509DataType->X509SubjectName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509SubjectName>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (X509Certificate, base64Binary (base64Binary)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Certificate");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509Certificate.bytesLen, &X509DataType->X509Certificate.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509Certificate.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509Certificate.bytesLen ? (unsigned char) X509DataType->X509Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509Certificate_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Certificate>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (X509CRL, base64Binary (base64Binary)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509CRL");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509CRL");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->X509CRL.bytesLen, &X509DataType->X509CRL.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->X509CRL.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->X509CRL.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->X509CRL.bytesLen ? (unsigned char) X509DataType->X509CRL.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->X509CRL.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->X509CRL_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509CRL>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &X509DataType->ANY.bytesLen, &X509DataType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((X509DataType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < X509DataType->ANY.bytesLen;) {
                            uint32_t octet_a = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < X509DataType->ANY.bytesLen ? (unsigned char) X509DataType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[X509DataType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        X509DataType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}PGPData; type={http://www.w3.org/2000/09/xmldsig#}PGPDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True; sequence=True (2;
// Particle: PGPKeyID, base64Binary (1, 1); PGPKeyPacket, base64Binary (0, 1); ANY, anyType (0, 1); PGPKeyPacket, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso20_PGPDataType(exi_bitstream_t* stream, struct iso20_PGPDataType* PGPDataType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 37;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PGPDataType(PGPDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 37:
            // Grammar: ID=37; read/write bits=2; START (PGPKeyID), START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyID, base64Binary (base64Binary)); next=38
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyID");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyID");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyID.bytesLen, &PGPDataType->choice_1.PGPKeyID.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyID.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyID.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyID.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyID.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyID.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 38;
                    }




                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyID>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=39
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 39;
                    }




                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 38:
            // Grammar: ID=38; read/write bits=3; START (PGPKeyPacket), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=39
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.PGPKeyPacket.bytesLen, &PGPDataType->choice_1.PGPKeyPacket.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_1.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.PGPKeyPacket_isUsed = 1u;
                        grammar_id = 39;
                    }




                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 40;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 39:
            // Grammar: ID=39; read/write bits=3; START (ANY), END Element, END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_1.ANY.bytesLen, &PGPDataType->choice_1.ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_1.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_1.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_1.ANY.bytesLen ? (unsigned char) PGPDataType->choice_1.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_1.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_1.ANY_isUsed = 1u;
                        grammar_id = 40;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 40:
            // Grammar: ID=40; read/write bits=1; START (PGPKeyPacket)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PGPKeyPacket, base64Binary (base64Binary)); next=41
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.PGPKeyPacket.bytesLen, &PGPDataType->choice_2.PGPKeyPacket.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_2.PGPKeyPacket.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_2.PGPKeyPacket.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_2.PGPKeyPacket.bytesLen ? (unsigned char) PGPDataType->choice_2.PGPKeyPacket.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_2.PGPKeyPacket.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 41;
                    }




                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPKeyPacket>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 41:
            // Grammar: ID=41; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=40
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PGPDataType->choice_2.ANY.bytesLen, &PGPDataType->choice_2.ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PGPDataType->choice_2.ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PGPDataType->choice_2.ANY.bytesLen;) {
                            uint32_t octet_a = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < PGPDataType->choice_2.ANY.bytesLen ? (unsigned char) PGPDataType->choice_2.ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PGPDataType->choice_2.ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        PGPDataType->choice_2.ANY_isUsed = 1u;
                        grammar_id = 40;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}rationalNumber; type={urn:iso:std:iso:15118:-20:CommonTypes}RationalNumberType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Exponent, byte (1, 1); Value, short (1, 1);
static int decode_iso20_RationalNumberType(exi_bitstream_t* stream, struct iso20_RationalNumberType* RationalNumberType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 42;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_RationalNumberType(RationalNumberType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 42:
            // Grammar: ID=42; read/write bits=1; START (Exponent)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Exponent, byte (short)); next=43
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Exponent");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Exponent");
                    // decode: byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = -128
                                RationalNumberType->Exponent = (int8_t)(value + -128);
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", RationalNumberType->Exponent);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 43;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Exponent>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 43:
            // Grammar: ID=43; read/write bits=1; START (Value)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Value, short (int)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Value");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Value");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &RationalNumberType->Value);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", RationalNumberType->Value);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Value>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry; type={urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntryType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Duration, unsignedInt (1, 1); Power, RationalNumberType (1, 1); Power_L2, RationalNumberType (0, 1); Power_L3, RationalNumberType (0, 1);
static int decode_iso20_PowerScheduleEntryType(exi_bitstream_t* stream, struct iso20_PowerScheduleEntryType* PowerScheduleEntryType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 44;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PowerScheduleEntryType(PowerScheduleEntryType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 44:
            // Grammar: ID=44; read/write bits=1; START (Duration)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Duration, unsignedInt (unsignedLong)); next=45
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PowerScheduleEntryType->Duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PowerScheduleEntryType->Duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 45;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Duration>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 45:
            // Grammar: ID=45; read/write bits=1; START (Power)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Power, RationalNumberType (RationalNumberType)); next=46
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Power");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Power");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleEntryType->Power, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 46;
                    }


                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Power>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 46:
            // Grammar: ID=46; read/write bits=2; START (Power_L2), START (Power_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Power_L2, RationalNumberType (RationalNumberType)); next=47
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L2");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L2");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleEntryType->Power_L2, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleEntryType->Power_L2_isUsed = 1u;
                        grammar_id = 47;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Power_L2>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Power_L3, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleEntryType->Power_L3, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleEntryType->Power_L3_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 47:
            // Grammar: ID=47; read/write bits=2; START (Power_L3), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Power_L3, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleEntryType->Power_L3, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleEntryType->Power_L3_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Power_L3>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EnergyFee, RationalNumberType (1, 1); PowerRangeStart, RationalNumberType (1, 1);
static int decode_iso20_EVPriceRuleType(exi_bitstream_t* stream, struct iso20_EVPriceRuleType* EVPriceRuleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 48;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPriceRuleType(EVPriceRuleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 48:
            // Grammar: ID=48; read/write bits=1; START (EnergyFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyFee, RationalNumberType (RationalNumberType)); next=49
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &EVPriceRuleType->EnergyFee, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 49;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 49:
            // Grammar: ID=49; read/write bits=1; START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &EVPriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntryType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Duration, unsignedInt (1, 1); Power, RationalNumberType (1, 1);
static int decode_iso20_EVPowerScheduleEntryType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleEntryType* EVPowerScheduleEntryType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 50;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPowerScheduleEntryType(EVPowerScheduleEntryType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 50:
            // Grammar: ID=50; read/write bits=1; START (Duration)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Duration, unsignedInt (unsignedLong)); next=51
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &EVPowerScheduleEntryType->Duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", EVPowerScheduleEntryType->Duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 51;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Duration>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 51:
            // Grammar: ID=51; read/write bits=1; START (Power)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Power, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Power");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Power");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &EVPowerScheduleEntryType->Power, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Power>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStackType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Duration, unsignedInt (1, 1); EVPriceRule, EVPriceRuleType (1, 8);
static int decode_iso20_EVPriceRuleStackType(exi_bitstream_t* stream, struct iso20_EVPriceRuleStackType* EVPriceRuleStackType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 52;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPriceRuleStackType(EVPriceRuleStackType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 52:
            // Grammar: ID=52; read/write bits=1; START (Duration)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Duration, unsignedInt (unsignedLong)); next=53
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &EVPriceRuleStackType->Duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", EVPriceRuleStackType->Duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 53;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Duration>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 53:
            // Grammar: ID=53; read/write bits=1; START (EVPriceRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPriceRule, EVPriceRuleType (EVPriceRuleType)); next=54
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule");
                    // decode: element array
                    if (EVPriceRuleStackType->EVPriceRule.arrayLen < iso20_EVPriceRuleType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPriceRuleType(stream, &EVPriceRuleStackType->EVPriceRule.array[EVPriceRuleStackType->EVPriceRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPriceRuleType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 54;

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 54:
            // Grammar: ID=54; read/write bits=2; LOOP (EVPriceRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (EVPriceRule, EVPriceRuleType (EVPriceRuleType)); next=54
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule");
                    // decode: element array
                    if (EVPriceRuleStackType->EVPriceRule.arrayLen < iso20_EVPriceRuleType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPriceRuleType(stream, &EVPriceRuleStackType->EVPriceRule.array[EVPriceRuleStackType->EVPriceRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPriceRuleType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (EVPriceRuleStackType->EVPriceRule.arrayLen < 8)
                    {
                        grammar_id = 54;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceRule; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EnergyFee, RationalNumberType (1, 1); ParkingFee, RationalNumberType (0, 1); ParkingFeePeriod, unsignedInt (0, 1); CarbonDioxideEmission, unsignedShort (0, 1); RenewableGenerationPercentage, unsignedByte (0, 1); PowerRangeStart, RationalNumberType (1, 1);
static int decode_iso20_PriceRuleType(exi_bitstream_t* stream, struct iso20_PriceRuleType* PriceRuleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 55;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceRuleType(PriceRuleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 55:
            // Grammar: ID=55; read/write bits=1; START (EnergyFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyFee, RationalNumberType (RationalNumberType)); next=56
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->EnergyFee, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 56;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EnergyFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 56:
            // Grammar: ID=56; read/write bits=3; START (ParkingFee), START (ParkingFeePeriod), START (CarbonDioxideEmission), START (RenewableGenerationPercentage), START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParkingFee, RationalNumberType (RationalNumberType)); next=57
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFee");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->ParkingFee, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PriceRuleType->ParkingFee_isUsed = 1u;
                        grammar_id = 57;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFee>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (ParkingFeePeriod, unsignedInt (unsignedLong)); next=58
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PriceRuleType->ParkingFeePeriod);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleType->ParkingFeePeriod);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        PriceRuleType->ParkingFeePeriod_isUsed = 1u;
                        grammar_id = 58;
                    }

                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (CarbonDioxideEmission, unsignedShort (unsignedInt)); next=59
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &PriceRuleType->CarbonDioxideEmission);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleType->CarbonDioxideEmission);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        PriceRuleType->CarbonDioxideEmission_isUsed = 1u;
                        grammar_id = 59;
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (RenewableGenerationPercentage, unsignedByte (unsignedShort)); next=60
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceRuleType->RenewableGenerationPercentage = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceRuleType->RenewableGenerationPercentage);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                PriceRuleType->RenewableGenerationPercentage_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 60;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 57:
            // Grammar: ID=57; read/write bits=3; START (ParkingFeePeriod), START (CarbonDioxideEmission), START (RenewableGenerationPercentage), START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParkingFeePeriod, unsignedInt (unsignedLong)); next=58
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PriceRuleType->ParkingFeePeriod);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleType->ParkingFeePeriod);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        PriceRuleType->ParkingFeePeriod_isUsed = 1u;
                        grammar_id = 58;
                    }

                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParkingFeePeriod>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (CarbonDioxideEmission, unsignedShort (unsignedInt)); next=59
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &PriceRuleType->CarbonDioxideEmission);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleType->CarbonDioxideEmission);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        PriceRuleType->CarbonDioxideEmission_isUsed = 1u;
                        grammar_id = 59;
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (RenewableGenerationPercentage, unsignedByte (unsignedShort)); next=60
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceRuleType->RenewableGenerationPercentage = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceRuleType->RenewableGenerationPercentage);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                PriceRuleType->RenewableGenerationPercentage_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 60;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 58:
            // Grammar: ID=58; read/write bits=2; START (CarbonDioxideEmission), START (RenewableGenerationPercentage), START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CarbonDioxideEmission, unsignedShort (unsignedInt)); next=59
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &PriceRuleType->CarbonDioxideEmission);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleType->CarbonDioxideEmission);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        PriceRuleType->CarbonDioxideEmission_isUsed = 1u;
                        grammar_id = 59;
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CarbonDioxideEmission>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (RenewableGenerationPercentage, unsignedByte (unsignedShort)); next=60
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceRuleType->RenewableGenerationPercentage = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceRuleType->RenewableGenerationPercentage);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                PriceRuleType->RenewableGenerationPercentage_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 60;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 59:
            // Grammar: ID=59; read/write bits=2; START (RenewableGenerationPercentage), START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (RenewableGenerationPercentage, unsignedByte (unsignedShort)); next=60
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceRuleType->RenewableGenerationPercentage = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceRuleType->RenewableGenerationPercentage);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                PriceRuleType->RenewableGenerationPercentage_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 60;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}RenewableGenerationPercentage>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 60:
            // Grammar: ID=60; read/write bits=1; START (PowerRangeStart)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerRangeStart, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PriceRuleType->PowerRangeStart, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerRangeStart>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries; type={urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntryListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PowerScheduleEntry, PowerScheduleEntryType (1, 1024);
static int decode_iso20_PowerScheduleEntryListType(exi_bitstream_t* stream, struct iso20_PowerScheduleEntryListType* PowerScheduleEntryListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 61;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PowerScheduleEntryListType(PowerScheduleEntryListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 61:
            // Grammar: ID=61; read/write bits=1; START (PowerScheduleEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerScheduleEntry, PowerScheduleEntryType (PowerScheduleEntryType)); next=62
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry");
                    // decode: element array
                    if (PowerScheduleEntryListType->PowerScheduleEntry.arrayLen < iso20_PowerScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_PowerScheduleEntryType(stream, &PowerScheduleEntryListType->PowerScheduleEntry.array[PowerScheduleEntryListType->PowerScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PowerScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 62;

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 62:
            // Grammar: ID=62; read/write bits=2; LOOP (PowerScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (PowerScheduleEntry, PowerScheduleEntryType (PowerScheduleEntryType)); next=62
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry");
                    // decode: element array
                    if (PowerScheduleEntryListType->PowerScheduleEntry.arrayLen < iso20_PowerScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_PowerScheduleEntryType(stream, &PowerScheduleEntryListType->PowerScheduleEntry.array[PowerScheduleEntryListType->PowerScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PowerScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (PowerScheduleEntryListType->PowerScheduleEntry.arrayLen < 1024)
                    {
                        grammar_id = 62;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}TaxRule; type={urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TaxRuleID, numericIDType (1, 1); TaxRuleName, nameType (0, 1); TaxRate, RationalNumberType (1, 1); TaxIncludedInPrice, boolean (0, 1); AppliesToEnergyFee, boolean (1, 1); AppliesToParkingFee, boolean (1, 1); AppliesToOverstayFee, boolean (1, 1); AppliesMinimumMaximumCost, boolean (1, 1);
static int decode_iso20_TaxRuleType(exi_bitstream_t* stream, struct iso20_TaxRuleType* TaxRuleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 63;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_TaxRuleType(TaxRuleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 63:
            // Grammar: ID=63; read/write bits=1; START (TaxRuleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRuleID, numericIDType (unsignedInt)); next=64
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &TaxRuleType->TaxRuleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", TaxRuleType->TaxRuleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 64;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 64:
            // Grammar: ID=64; read/write bits=2; START (TaxRuleName), START (TaxRate)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRuleName, nameType (string)); next=65
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleName");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &TaxRuleType->TaxRuleName.charactersLen);
                            if (error == 0)
                            {
                                if (TaxRuleType->TaxRuleName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    TaxRuleType->TaxRuleName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, TaxRuleType->TaxRuleName.charactersLen, TaxRuleType->TaxRuleName.characters, iso20_TaxRuleName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + TaxRuleType->TaxRuleName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < TaxRuleType->TaxRuleName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(TaxRuleType->TaxRuleName.characters[i]))
                                        {
                                            TaxRuleType->TaxRuleName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, TaxRuleType->TaxRuleName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                TaxRuleType->TaxRuleName_isUsed = 1u;
                                grammar_id = 65;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleName>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TaxRate, RationalNumberType (RationalNumberType)); next=66
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &TaxRuleType->TaxRate, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 66;
                    }


                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 65:
            // Grammar: ID=65; read/write bits=1; START (TaxRate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRate, RationalNumberType (RationalNumberType)); next=66
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &TaxRuleType->TaxRate, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 66;
                    }


                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 66:
            // Grammar: ID=66; read/write bits=2; START (TaxIncludedInPrice), START (AppliesToEnergyFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxIncludedInPrice, boolean (boolean)); next=67
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxIncludedInPrice");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxIncludedInPrice");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->TaxIncludedInPrice = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                TaxRuleType->TaxIncludedInPrice_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 67;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxIncludedInPrice>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AppliesToEnergyFee, boolean (boolean)); next=68
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->AppliesToEnergyFee = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 68;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 67:
            // Grammar: ID=67; read/write bits=1; START (AppliesToEnergyFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AppliesToEnergyFee, boolean (boolean)); next=68
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->AppliesToEnergyFee = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 68;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToEnergyFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 68:
            // Grammar: ID=68; read/write bits=1; START (AppliesToParkingFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AppliesToParkingFee, boolean (boolean)); next=69
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToParkingFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToParkingFee");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->AppliesToParkingFee = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 69;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToParkingFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 69:
            // Grammar: ID=69; read/write bits=1; START (AppliesToOverstayFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AppliesToOverstayFee, boolean (boolean)); next=70
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToOverstayFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToOverstayFee");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->AppliesToOverstayFee = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 70;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AppliesToOverstayFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 70:
            // Grammar: ID=70; read/write bits=1; START (AppliesMinimumMaximumCost)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AppliesMinimumMaximumCost, boolean (boolean)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesMinimumMaximumCost");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AppliesMinimumMaximumCost");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                TaxRuleType->AppliesMinimumMaximumCost = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AppliesMinimumMaximumCost>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStackType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Duration, unsignedInt (1, 1); PriceRule, PriceRuleType (1, 8);
static int decode_iso20_PriceRuleStackType(exi_bitstream_t* stream, struct iso20_PriceRuleStackType* PriceRuleStackType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 71;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceRuleStackType(PriceRuleStackType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 71:
            // Grammar: ID=71; read/write bits=1; START (Duration)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Duration, unsignedInt (unsignedLong)); next=72
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Duration");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PriceRuleStackType->Duration);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceRuleStackType->Duration);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 72;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Duration>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 72:
            // Grammar: ID=72; read/write bits=1; START (PriceRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceRule, PriceRuleType (PriceRuleType)); next=73
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule");
                    // decode: element array
                    if (PriceRuleStackType->PriceRule.arrayLen < iso20_PriceRuleType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceRuleType(stream, &PriceRuleStackType->PriceRule.array[PriceRuleStackType->PriceRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceRuleType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 73;

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 73:
            // Grammar: ID=73; read/write bits=2; LOOP (PriceRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (PriceRule, PriceRuleType (PriceRuleType)); next=73
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule");
                    // decode: element array
                    if (PriceRuleStackType->PriceRule.arrayLen < iso20_PriceRuleType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceRuleType(stream, &PriceRuleStackType->PriceRule.array[PriceRuleStackType->PriceRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceRuleType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (PriceRuleStackType->PriceRule.arrayLen < 8)
                    {
                        grammar_id = 73;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService; type={urn:iso:std:iso:15118:-20:CommonMessages}AdditionalServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceName, nameType (1, 1); ServiceFee, RationalNumberType (1, 1);
static int decode_iso20_AdditionalServiceType(exi_bitstream_t* stream, struct iso20_AdditionalServiceType* AdditionalServiceType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 74;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AdditionalServiceType(AdditionalServiceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 74:
            // Grammar: ID=74; read/write bits=1; START (ServiceName)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceName, nameType (string)); next=75
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceName");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AdditionalServiceType->ServiceName.charactersLen);
                            if (error == 0)
                            {
                                if (AdditionalServiceType->ServiceName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AdditionalServiceType->ServiceName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AdditionalServiceType->ServiceName.charactersLen, AdditionalServiceType->ServiceName.characters, iso20_ServiceName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AdditionalServiceType->ServiceName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AdditionalServiceType->ServiceName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AdditionalServiceType->ServiceName.characters[i]))
                                        {
                                            AdditionalServiceType->ServiceName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AdditionalServiceType->ServiceName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 75;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceName>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 75:
            // Grammar: ID=75; read/write bits=1; START (ServiceFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceFee, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceFee");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &AdditionalServiceType->ServiceFee, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PowerSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); AvailableEnergy, RationalNumberType (0, 1); PowerTolerance, RationalNumberType (0, 1); PowerScheduleEntries, PowerScheduleEntryListType (1, 1);
static int decode_iso20_PowerScheduleType(exi_bitstream_t* stream, struct iso20_PowerScheduleType* PowerScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 76;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PowerScheduleType(PowerScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 76:
            // Grammar: ID=76; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=77
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &PowerScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", PowerScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 77;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 77:
            // Grammar: ID=77; read/write bits=2; START (AvailableEnergy), START (PowerTolerance), START (PowerScheduleEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AvailableEnergy, RationalNumberType (RationalNumberType)); next=78
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AvailableEnergy");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AvailableEnergy");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleType->AvailableEnergy, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleType->AvailableEnergy_isUsed = 1u;
                        grammar_id = 78;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AvailableEnergy>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PowerTolerance, RationalNumberType (RationalNumberType)); next=79
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleType->PowerTolerance, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleType->PowerTolerance_isUsed = 1u;
                        grammar_id = 79;
                    }


                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (PowerScheduleEntries, PowerScheduleEntryListType (PowerScheduleEntryListType)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    // decode: element
                    error = decode_iso20_PowerScheduleEntryListType(stream, &PowerScheduleType->PowerScheduleEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 78:
            // Grammar: ID=78; read/write bits=2; START (PowerTolerance), START (PowerScheduleEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerTolerance, RationalNumberType (RationalNumberType)); next=79
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &PowerScheduleType->PowerTolerance, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerScheduleType->PowerTolerance_isUsed = 1u;
                        grammar_id = 79;
                    }


                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerTolerance>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PowerScheduleEntries, PowerScheduleEntryListType (PowerScheduleEntryListType)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    // decode: element
                    error = decode_iso20_PowerScheduleEntryListType(stream, &PowerScheduleType->PowerScheduleEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 79:
            // Grammar: ID=79; read/write bits=1; START (PowerScheduleEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerScheduleEntries, PowerScheduleEntryListType (PowerScheduleEntryListType)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries");
                    // decode: element
                    error = decode_iso20_PowerScheduleEntryListType(stream, &PowerScheduleType->PowerScheduleEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerScheduleEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntries; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntryListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVPowerScheduleEntry, EVPowerScheduleEntryType (1, 1024);
static int decode_iso20_EVPowerScheduleEntryListType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleEntryListType* EVPowerScheduleEntryListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 80;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPowerScheduleEntryListType(EVPowerScheduleEntryListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 80:
            // Grammar: ID=80; read/write bits=1; START (EVPowerScheduleEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerScheduleEntry, EVPowerScheduleEntryType (EVPowerScheduleEntryType)); next=81
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry");
                    // decode: element array
                    if (EVPowerScheduleEntryListType->EVPowerScheduleEntry.arrayLen < iso20_EVPowerScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPowerScheduleEntryType(stream, &EVPowerScheduleEntryListType->EVPowerScheduleEntry.array[EVPowerScheduleEntryListType->EVPowerScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPowerScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 81;

                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 81:
            // Grammar: ID=81; read/write bits=2; LOOP (EVPowerScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (EVPowerScheduleEntry, EVPowerScheduleEntryType (EVPowerScheduleEntryType)); next=81
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry");
                    // decode: element array
                    if (EVPowerScheduleEntryListType->EVPowerScheduleEntry.arrayLen < iso20_EVPowerScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPowerScheduleEntryType(stream, &EVPowerScheduleEntryListType->EVPowerScheduleEntry.array[EVPowerScheduleEntryListType->EVPowerScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPowerScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (EVPowerScheduleEntryListType->EVPowerScheduleEntry.arrayLen < 1024)
                    {
                        grammar_id = 81;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule; type={urn:iso:std:iso:15118:-20:CommonMessages}OverstayRuleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: OverstayRuleDescription, descriptionType (0, 1); StartTime, unsignedInt (1, 1); OverstayFee, RationalNumberType (1, 1); OverstayFeePeriod, unsignedInt (1, 1);
static int decode_iso20_OverstayRuleType(exi_bitstream_t* stream, struct iso20_OverstayRuleType* OverstayRuleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 82;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_OverstayRuleType(OverstayRuleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 82:
            // Grammar: ID=82; read/write bits=2; START (OverstayRuleDescription), START (StartTime)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayRuleDescription, descriptionType (string)); next=83
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRuleDescription");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRuleDescription");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &OverstayRuleType->OverstayRuleDescription.charactersLen);
                            if (error == 0)
                            {
                                if (OverstayRuleType->OverstayRuleDescription.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    OverstayRuleType->OverstayRuleDescription.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, OverstayRuleType->OverstayRuleDescription.charactersLen, OverstayRuleType->OverstayRuleDescription.characters, iso20_OverstayRuleDescription_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + OverstayRuleType->OverstayRuleDescription.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < OverstayRuleType->OverstayRuleDescription.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(OverstayRuleType->OverstayRuleDescription.characters[i]))
                                        {
                                            OverstayRuleType->OverstayRuleDescription.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, OverstayRuleType->OverstayRuleDescription.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                OverstayRuleType->OverstayRuleDescription_isUsed = 1u;
                                grammar_id = 83;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRuleDescription>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (StartTime, unsignedInt (unsignedLong)); next=84
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}StartTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}StartTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &OverstayRuleType->StartTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", OverstayRuleType->StartTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 84;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}StartTime>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 83:
            // Grammar: ID=83; read/write bits=1; START (StartTime)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (StartTime, unsignedInt (unsignedLong)); next=84
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}StartTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}StartTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &OverstayRuleType->StartTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", OverstayRuleType->StartTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 84;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}StartTime>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 84:
            // Grammar: ID=84; read/write bits=1; START (OverstayFee)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayFee, RationalNumberType (RationalNumberType)); next=85
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFee");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFee");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &OverstayRuleType->OverstayFee, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 85;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFee>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 85:
            // Grammar: ID=85; read/write bits=1; START (OverstayFeePeriod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayFeePeriod, unsignedInt (unsignedLong)); next=2
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFeePeriod");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFeePeriod");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &OverstayRuleType->OverstayFeePeriod);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", OverstayRuleType->OverstayFeePeriod);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayFeePeriod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStacks; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStackListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVPriceRuleStack, EVPriceRuleStackType (1, 1024);
static int decode_iso20_EVPriceRuleStackListType(exi_bitstream_t* stream, struct iso20_EVPriceRuleStackListType* EVPriceRuleStackListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 86;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPriceRuleStackListType(EVPriceRuleStackListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 86:
            // Grammar: ID=86; read/write bits=1; START (EVPriceRuleStack)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPriceRuleStack, EVPriceRuleStackType (EVPriceRuleStackType)); next=87
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack");
                    // decode: element array
                    if (EVPriceRuleStackListType->EVPriceRuleStack.arrayLen < iso20_EVPriceRuleStackType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPriceRuleStackType(stream, &EVPriceRuleStackListType->EVPriceRuleStack.array[EVPriceRuleStackListType->EVPriceRuleStack.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPriceRuleStackType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 87;

                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 87:
            // Grammar: ID=87; read/write bits=2; LOOP (EVPriceRuleStack), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (EVPriceRuleStack, EVPriceRuleStackType (EVPriceRuleStackType)); next=87
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack");
                    // decode: element array
                    if (EVPriceRuleStackListType->EVPriceRuleStack.arrayLen < iso20_EVPriceRuleStackType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_EVPriceRuleStackType(stream, &EVPriceRuleStackListType->EVPriceRuleStack.array[EVPriceRuleStackListType->EVPriceRuleStack.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_EVPriceRuleStackType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (EVPriceRuleStackListType->EVPriceRuleStack.arrayLen < 1024)
                    {
                        grammar_id = 87;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStack>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SPKIData; type={http://www.w3.org/2000/09/xmldsig#}SPKIDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SPKISexp, base64Binary (1, 1); ANY, anyType (0, 1);
static int decode_iso20_SPKIDataType(exi_bitstream_t* stream, struct iso20_SPKIDataType* SPKIDataType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 88;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SPKIDataType(SPKIDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 88:
            // Grammar: ID=88; read/write bits=1; START (SPKISexp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SPKISexp, base64Binary (base64Binary)); next=89
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKISexp");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKISexp");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->SPKISexp.bytesLen, &SPKIDataType->SPKISexp.bytes[0], iso20_base64Binary_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SPKIDataType->SPKISexp.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SPKIDataType->SPKISexp.bytesLen;) {
                            uint32_t octet_a = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            uint32_t octet_b = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            uint32_t octet_c = i < SPKIDataType->SPKISexp.bytesLen ? (unsigned char) SPKIDataType->SPKISexp.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SPKIDataType->SPKISexp.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 89;
                    }




                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKISexp>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 89:
            // Grammar: ID=89; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SPKIDataType->ANY.bytesLen, &SPKIDataType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SPKIDataType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SPKIDataType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SPKIDataType->ANY.bytesLen ? (unsigned char) SPKIDataType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SPKIDataType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SPKIDataType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignedInfo; type={http://www.w3.org/2000/09/xmldsig#}SignedInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); CanonicalizationMethod, CanonicalizationMethodType (1, 1); SignatureMethod, SignatureMethodType (1, 1); Reference, ReferenceType (1, 4) (original max unbounded);
static int decode_iso20_SignedInfoType(exi_bitstream_t* stream, struct iso20_SignedInfoType* SignedInfoType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 90;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignedInfoType(SignedInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 90:
            // Grammar: ID=90; read/write bits=2; START (Id), START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=91
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedInfoType->Id.charactersLen, SignedInfoType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignedInfoType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignedInfoType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignedInfoType->Id.characters[i]))
                                {
                                    SignedInfoType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignedInfoType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignedInfoType->Id_isUsed = 1u;
                    grammar_id = 91;

                    }
                    break;
                case 1:
                    {
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=92
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    // decode: element
                    error = decode_iso20_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 92;
                    }


                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 91:
            // Grammar: ID=91; read/write bits=1; START (CanonicalizationMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CanonicalizationMethod, CanonicalizationMethodType (CanonicalizationMethodType)); next=92
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod");
                    // decode: element
                    error = decode_iso20_CanonicalizationMethodType(stream, &SignedInfoType->CanonicalizationMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 92;
                    }


                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 92:
            // Grammar: ID=92; read/write bits=1; START (SignatureMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureMethod, SignatureMethodType (SignatureMethodType)); next=93
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureMethod");
                    // decode: element
                    error = decode_iso20_SignatureMethodType(stream, &SignedInfoType->SignatureMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 93;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 93:
            // Grammar: ID=93; read/write bits=1; START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=94
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 94;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 94:
            // Grammar: ID=94; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=94
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (SignedInfoType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &SignedInfoType->Reference.array[SignedInfoType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 94;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); EVPowerScheduleEntries, EVPowerScheduleEntryListType (1, 1);
static int decode_iso20_EVPowerScheduleType(exi_bitstream_t* stream, struct iso20_EVPowerScheduleType* EVPowerScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 95;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPowerScheduleType(EVPowerScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 95:
            // Grammar: ID=95; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=96
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &EVPowerScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", EVPowerScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 96;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 96:
            // Grammar: ID=96; read/write bits=1; START (EVPowerScheduleEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerScheduleEntries, EVPowerScheduleEntryListType (EVPowerScheduleEntryListType)); next=2
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntries");
                    // decode: element
                    error = decode_iso20_EVPowerScheduleEntryListType(stream, &EVPowerScheduleType->EVPowerScheduleEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerScheduleEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureValue; type={http://www.w3.org/2000/09/xmldsig#}SignatureValueType; base type=base64Binary; content type=simple;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); CONTENT, SignatureValueType (1, 1);
static int decode_iso20_SignatureValueType(exi_bitstream_t* stream, struct iso20_SignatureValueType* SignatureValueType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 97;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignatureValueType(SignatureValueType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 97:
            // Grammar: ID=97; read/write bits=2; START (Id), START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=98
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureValueType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureValueType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureValueType->Id.charactersLen, SignatureValueType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignatureValueType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignatureValueType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureValueType->Id.characters[i]))
                                {
                                    SignatureValueType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureValueType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureValueType->Id_isUsed = 1u;
                    grammar_id = 98;

                    }
                    break;
                case 1:
                    {
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=2
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso20_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureValueType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureValueType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureValueType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 2;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 98:
            // Grammar: ID=98; read/write bits=1; START (CONTENT)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CONTENT, SignatureValueType (base64Binary)); next=2
                    // decode exi type: base64Binary (simple)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureValueType->CONTENT.bytesLen);
                    if (error == 0)
                    {
                        error = exi_basetypes_decoder_bytes(stream, SignatureValueType->CONTENT.bytesLen, &SignatureValueType->CONTENT.bytes[0], iso20_SignatureValueType_BYTES_SIZE);
                        if (error == 0)
                        {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignatureValueType->CONTENT.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignatureValueType->CONTENT.bytesLen;) {
                            uint32_t octet_a = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_b = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            uint32_t octet_c = i < SignatureValueType->CONTENT.bytesLen ? (unsigned char) SignatureValueType->CONTENT.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignatureValueType->CONTENT.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                            grammar_id = 2;
                        }
                    }
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates; type={urn:iso:std:iso:15118:-20:CommonMessages}SubCertificatesType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Certificate, certificateType (1, 3);
static int decode_iso20_SubCertificatesType(exi_bitstream_t* stream, struct iso20_SubCertificatesType* SubCertificatesType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 99;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SubCertificatesType(SubCertificatesType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 99:
            // Grammar: ID=99; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=100
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso20_certificateType_3_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso20_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 100;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 100:
            // Grammar: ID=100; read/write bits=2; LOOP (Certificate), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Certificate, certificateType (base64Binary)); next=100
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    // decode exi type: base64Binary (Array)
                    if (SubCertificatesType->Certificate.arrayLen < iso20_certificateType_3_ARRAY_SIZE)
                    {
                        error = decode_exi_type_hex_binary(stream, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen, &SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[0], iso20_certificateType_BYTES_SIZE);
                        if (error == 0)
                        {
                            // Binary to Base64:
                            char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                            int mod_table[] = {0, 2, 1};
                            size_t output_length = 4 * ((SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen + 2) / 3);
                            unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                            for (int i = 0, j = 0; i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen;) {
                                uint32_t octet_a = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_b = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                uint32_t octet_c = i < SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen ? (unsigned char) SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytes[i++] : 0;
                                
                                uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                                
                                encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                                encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                            }
                            for (int i = 0; i < mod_table[SubCertificatesType->Certificate.array[SubCertificatesType->Certificate.arrayLen].bytesLen % 3]; i++) {
                                encoded_data[output_length - 1 - i] = '=';
                            }
                            if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                            strcat(xmlOut, ">");
                            strncat(xmlOut, (char*)encoded_data, output_length);
                            free(encoded_data);
                            SubCertificatesType->Certificate.arrayLen++;
                            grammar_id = 100;
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Certificate>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Parameter; type={urn:iso:std:iso:15118:-20:CommonMessages}ParameterType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False; choice=True;
// Particle: Name, nameType (1, 1); boolValue, boolean (0, 1); byteValue, byte (0, 1); shortValue, short (0, 1); intValue, int (0, 1); rationalNumber, RationalNumberType (0, 1); finiteString, nameType (0, 1);
static int decode_iso20_ParameterType(exi_bitstream_t* stream, struct iso20_ParameterType* ParameterType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 101;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ParameterType(ParameterType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 101:
            // Grammar: ID=101; read/write bits=1; START (Name)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Name, nameType (string)); next=102
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Name");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ParameterType->Name.charactersLen);
                    if (error == 0)
                    {
                        if (ParameterType->Name.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ParameterType->Name.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ParameterType->Name.charactersLen, ParameterType->Name.characters, iso20_Name_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ParameterType->Name.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ParameterType->Name.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ParameterType->Name.characters[i]))
                                {
                                    ParameterType->Name.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ParameterType->Name.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 102;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 102:
            // Grammar: ID=102; read/write bits=3; START (boolValue), START (byteValue), START (shortValue), START (intValue), START (rationalNumber), START (finiteString)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (boolValue, boolean (boolean)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}boolValue");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}boolValue");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ParameterType->boolValue = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ParameterType->boolValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}boolValue>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (byteValue, byte (short)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}byteValue");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}byteValue");
                    // decode: byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                // type has min_value = -128
                                ParameterType->byteValue = (int8_t)(value + -128);
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", ParameterType->byteValue);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                ParameterType->byteValue_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}byteValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (shortValue, short (int)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}shortValue");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}shortValue");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &ParameterType->shortValue);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", ParameterType->shortValue);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        ParameterType->shortValue_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}shortValue>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (intValue, int (long)); next=2
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}intValue");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}intValue");
                    // decode: int
                    error = decode_exi_type_integer32(stream, &ParameterType->intValue);
                    if (error == 0)
                    {
                        char append[12]; // max length: 10 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 12 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", ParameterType->intValue);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        ParameterType->intValue_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}intValue>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (rationalNumber, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}rationalNumber");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}rationalNumber");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &ParameterType->rationalNumber, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ParameterType->rationalNumber_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}rationalNumber>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (finiteString, nameType (string)); next=2
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}finiteString");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}finiteString");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &ParameterType->finiteString.charactersLen);
                            if (error == 0)
                            {
                                if (ParameterType->finiteString.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    ParameterType->finiteString.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, ParameterType->finiteString.charactersLen, ParameterType->finiteString.characters, iso20_finiteString_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + ParameterType->finiteString.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < ParameterType->finiteString.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(ParameterType->finiteString.characters[i]))
                                        {
                                            ParameterType->finiteString.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, ParameterType->finiteString.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                ParameterType->finiteString_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}finiteString>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVAbsolutePriceSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}EVAbsolutePriceScheduleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); Currency, currencyType (1, 1); PriceAlgorithm, identifierType (1, 1); EVPriceRuleStacks, EVPriceRuleStackListType (1, 1);
static int decode_iso20_EVAbsolutePriceScheduleType(exi_bitstream_t* stream, struct iso20_EVAbsolutePriceScheduleType* EVAbsolutePriceScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 103;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVAbsolutePriceScheduleType(EVAbsolutePriceScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 103:
            // Grammar: ID=103; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=104
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &EVAbsolutePriceScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", EVAbsolutePriceScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 104;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 104:
            // Grammar: ID=104; read/write bits=1; START (Currency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Currency, currencyType (string)); next=105
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVAbsolutePriceScheduleType->Currency.charactersLen);
                            if (error == 0)
                            {
                                if (EVAbsolutePriceScheduleType->Currency.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVAbsolutePriceScheduleType->Currency.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVAbsolutePriceScheduleType->Currency.charactersLen, EVAbsolutePriceScheduleType->Currency.characters, iso20_Currency_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + EVAbsolutePriceScheduleType->Currency.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < EVAbsolutePriceScheduleType->Currency.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(EVAbsolutePriceScheduleType->Currency.characters[i]))
                                        {
                                            EVAbsolutePriceScheduleType->Currency.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, EVAbsolutePriceScheduleType->Currency.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 105;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Currency>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 105:
            // Grammar: ID=105; read/write bits=1; START (PriceAlgorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceAlgorithm, identifierType (string)); next=106
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen);
                            if (error == 0)
                            {
                                if (EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen, EVAbsolutePriceScheduleType->PriceAlgorithm.characters, iso20_PriceAlgorithm_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < EVAbsolutePriceScheduleType->PriceAlgorithm.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(EVAbsolutePriceScheduleType->PriceAlgorithm.characters[i]))
                                        {
                                            EVAbsolutePriceScheduleType->PriceAlgorithm.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, EVAbsolutePriceScheduleType->PriceAlgorithm.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 106;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 106:
            // Grammar: ID=106; read/write bits=1; START (EVPriceRuleStacks)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPriceRuleStacks, EVPriceRuleStackListType (EVPriceRuleStackListType)); next=2
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStacks");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStacks");
                    // decode: element
                    error = decode_iso20_EVPriceRuleStackListType(stream, &EVAbsolutePriceScheduleType->EVPriceRuleStacks, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPriceRuleStacks>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedCostType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Amount, RationalNumberType (1, 1); CostPerUnit, RationalNumberType (1, 1);
static int decode_iso20_DetailedCostType(exi_bitstream_t* stream, struct iso20_DetailedCostType* DetailedCostType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 107;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_DetailedCostType(DetailedCostType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 107:
            // Grammar: ID=107; read/write bits=1; START (Amount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Amount, RationalNumberType (RationalNumberType)); next=108
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Amount");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Amount");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &DetailedCostType->Amount, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 108;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Amount>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 108:
            // Grammar: ID=108; read/write bits=1; START (CostPerUnit)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CostPerUnit, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}CostPerUnit");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}CostPerUnit");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &DetailedCostType->CostPerUnit, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}CostPerUnit>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}KeyInfo; type={http://www.w3.org/2000/09/xmldsig#}KeyInfoType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); KeyName, string (0, 1); KeyValue, KeyValueType (0, 1); RetrievalMethod, RetrievalMethodType (0, 1); X509Data, X509DataType (0, 1); PGPData, PGPDataType (0, 1); SPKIData, SPKIDataType (0, 1); MgmtData, string (0, 1); ANY, anyType (0, 1);
static int decode_iso20_KeyInfoType(exi_bitstream_t* stream, struct iso20_KeyInfoType* KeyInfoType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 109;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_KeyInfoType(KeyInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 109:
            // Grammar: ID=109; read/write bits=4; START (Id), START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=110
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (KeyInfoType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            KeyInfoType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, KeyInfoType->Id.charactersLen, KeyInfoType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + KeyInfoType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < KeyInfoType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(KeyInfoType->Id.characters[i]))
                                {
                                    KeyInfoType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, KeyInfoType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    KeyInfoType->Id_isUsed = 1u;
                    grammar_id = 110;

                    }
                    break;
                case 1:
                    {
                    // Event: START (KeyName, string (string)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_KeyName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + KeyInfoType->KeyName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < KeyInfoType->KeyName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->KeyName.characters[i]))
                                        {
                                            KeyInfoType->KeyName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->KeyName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    // decode: element
                    error = decode_iso20_KeyValueType(stream, &KeyInfoType->KeyValue, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    // decode: element
                    error = decode_iso20_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (X509Data, X509DataType (X509DataType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    // decode: element
                    error = decode_iso20_X509DataType(stream, &KeyInfoType->X509Data, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    // decode: element
                    error = decode_iso20_PGPDataType(stream, &KeyInfoType->PGPData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                    }
                    break;
                case 6:
                    {
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    // decode: element
                    error = decode_iso20_SPKIDataType(stream, &KeyInfoType->SPKIData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                    }
                    break;
                case 7:
                    {
                    // Event: START (MgmtData, string (string)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_MgmtData_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + KeyInfoType->MgmtData.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < KeyInfoType->MgmtData.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->MgmtData.characters[i]))
                                        {
                                            KeyInfoType->MgmtData.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->MgmtData.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                    }
                    break;
                case 8:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyInfoType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyInfoType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyInfoType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 110:
            // Grammar: ID=110; read/write bits=4; START (KeyName), START (KeyValue), START (RetrievalMethod), START (X509Data), START (PGPData), START (SPKIData), START (MgmtData), START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 4, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (KeyName, string (string)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyName");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->KeyName.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->KeyName.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->KeyName.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->KeyName.charactersLen, KeyInfoType->KeyName.characters, iso20_KeyName_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + KeyInfoType->KeyName.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < KeyInfoType->KeyName.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->KeyName.characters[i]))
                                        {
                                            KeyInfoType->KeyName.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->KeyName.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->KeyName_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (KeyValue, KeyValueType (KeyValueType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyValue");
                    // decode: element
                    error = decode_iso20_KeyValueType(stream, &KeyInfoType->KeyValue, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->KeyValue_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (RetrievalMethod, RetrievalMethodType (RetrievalMethodType)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod");
                    // decode: element
                    error = decode_iso20_RetrievalMethodType(stream, &KeyInfoType->RetrievalMethod, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->RetrievalMethod_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (X509Data, X509DataType (X509DataType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}X509Data");
                    // decode: element
                    error = decode_iso20_X509DataType(stream, &KeyInfoType->X509Data, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->X509Data_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (PGPData, PGPDataType (PGPDataType)); next=2
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}PGPData");
                    // decode: element
                    error = decode_iso20_PGPDataType(stream, &KeyInfoType->PGPData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->PGPData_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (SPKIData, SPKIDataType (SPKIDataType)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SPKIData");
                    // decode: element
                    error = decode_iso20_SPKIDataType(stream, &KeyInfoType->SPKIData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        KeyInfoType->SPKIData_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                    }
                    break;
                case 6:
                    {
                    // Event: START (MgmtData, string (string)); next=2
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}MgmtData");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &KeyInfoType->MgmtData.charactersLen);
                            if (error == 0)
                            {
                                if (KeyInfoType->MgmtData.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    KeyInfoType->MgmtData.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, KeyInfoType->MgmtData.charactersLen, KeyInfoType->MgmtData.characters, iso20_MgmtData_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + KeyInfoType->MgmtData.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < KeyInfoType->MgmtData.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(KeyInfoType->MgmtData.characters[i]))
                                        {
                                            KeyInfoType->MgmtData.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, KeyInfoType->MgmtData.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                KeyInfoType->MgmtData_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                    }
                    break;
                case 7:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &KeyInfoType->ANY.bytesLen, &KeyInfoType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((KeyInfoType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < KeyInfoType->ANY.bytesLen;) {
                            uint32_t octet_a = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < KeyInfoType->ANY.bytesLen ? (unsigned char) KeyInfoType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[KeyInfoType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        KeyInfoType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Object; type={http://www.w3.org/2000/09/xmldsig#}ObjectType; base type=; content type=mixed;
//          abstract=False; final=False;
// Particle: Encoding, anyURI (0, 1); Id, ID (0, 1); MimeType, string (0, 1); ANY, anyType (0, 1) (old 1, 1);
static int decode_iso20_ObjectType(exi_bitstream_t* stream, struct iso20_ObjectType* ObjectType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 111;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ObjectType(ObjectType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 111:
            // Grammar: ID=111; read/write bits=3; START (Encoding), START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Encoding, anyURI (anyURI)); next=112
                    if(strlen(xmlOut) + 8 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Encoding");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Encoding.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Encoding.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Encoding.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Encoding.charactersLen, ObjectType->Encoding.characters, iso20_Encoding_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->Encoding.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->Encoding.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Encoding.characters[i]))
                                {
                                    ObjectType->Encoding.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Encoding.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Encoding_isUsed = 1u;
                    grammar_id = 112;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Id, ID (NCName)); next=113
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Id.characters[i]))
                                {
                                    ObjectType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 113;

                    }
                    break;
                case 2:
                    {
                    // Event: START (MimeType, string (string)); next=114
                    if(strlen(xmlOut) + 8 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->MimeType.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 114;

                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 5:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 112:
            // Grammar: ID=112; read/write bits=3; START (Id), START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=113
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->Id.charactersLen, ObjectType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->Id.characters[i]))
                                {
                                    ObjectType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->Id_isUsed = 1u;
                    grammar_id = 113;

                    }
                    break;
                case 1:
                    {
                    // Event: START (MimeType, string (string)); next=114
                    if(strlen(xmlOut) + 8 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->MimeType.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 114;

                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 4:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 113:
            // Grammar: ID=113; read/write bits=3; START (MimeType), START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MimeType, string (string)); next=114
                    if(strlen(xmlOut) + 8 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " MimeType");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ObjectType->MimeType.charactersLen);
                    if (error == 0)
                    {
                        if (ObjectType->MimeType.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ObjectType->MimeType.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ObjectType->MimeType.charactersLen, ObjectType->MimeType.characters, iso20_MimeType_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ObjectType->MimeType.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ObjectType->MimeType.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ObjectType->MimeType.characters[i]))
                                {
                                    ObjectType->MimeType.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ObjectType->MimeType.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ObjectType->MimeType_isUsed = 1u;
                    grammar_id = 114;

                    }
                    break;
                case 1:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 3:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 114:
            // Grammar: ID=114; read/write bits=2; START (ANY), END Element, START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode: event not accepted
                    error = EXI_ERROR__UNKNOWN_EVENT_FOR_DECODING;
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                case 2:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ObjectType->ANY.bytesLen, &ObjectType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ObjectType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ObjectType->ANY.bytesLen;) {
                            uint32_t octet_a = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < ObjectType->ANY.bytesLen ? (unsigned char) ObjectType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ObjectType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        ObjectType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntries; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntryListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PriceLevelScheduleEntry, PriceLevelScheduleEntryType (1, 1024);
static int decode_iso20_PriceLevelScheduleEntryListType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleEntryListType* PriceLevelScheduleEntryListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 115;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceLevelScheduleEntryListType(PriceLevelScheduleEntryListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 115:
            // Grammar: ID=115; read/write bits=1; START (PriceLevelScheduleEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceLevelScheduleEntry, PriceLevelScheduleEntryType (PriceLevelScheduleEntryType)); next=116
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry");
                    // decode: element array
                    if (PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.arrayLen < iso20_PriceLevelScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceLevelScheduleEntryType(stream, &PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.array[PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceLevelScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 116;

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 116:
            // Grammar: ID=116; read/write bits=2; LOOP (PriceLevelScheduleEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (PriceLevelScheduleEntry, PriceLevelScheduleEntryType (PriceLevelScheduleEntryType)); next=116
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry");
                    // decode: element array
                    if (PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.arrayLen < iso20_PriceLevelScheduleEntryType_1024_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceLevelScheduleEntryType(stream, &PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.array[PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceLevelScheduleEntryType_1024_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (PriceLevelScheduleEntryListType->PriceLevelScheduleEntry.arrayLen < 1024)
                    {
                        grammar_id = 116;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts; type={urn:iso:std:iso:15118:-20:CommonTypes}DetailedTaxType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TaxRuleID, numericIDType (1, 1); Amount, RationalNumberType (1, 1);
static int decode_iso20_DetailedTaxType(exi_bitstream_t* stream, struct iso20_DetailedTaxType* DetailedTaxType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 117;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_DetailedTaxType(DetailedTaxType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 117:
            // Grammar: ID=117; read/write bits=1; START (TaxRuleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRuleID, numericIDType (unsignedInt)); next=118
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxRuleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxRuleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &DetailedTaxType->TaxRuleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", DetailedTaxType->TaxRuleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 118;
                    }

                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxRuleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 118:
            // Grammar: ID=118; read/write bits=1; START (Amount)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Amount, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Amount");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Amount");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &DetailedTaxType->Amount, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Amount>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}TaxRules; type={urn:iso:std:iso:15118:-20:CommonMessages}TaxRuleListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TaxRule, TaxRuleType (1, 10);
static int decode_iso20_TaxRuleListType(exi_bitstream_t* stream, struct iso20_TaxRuleListType* TaxRuleListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 119;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_TaxRuleListType(TaxRuleListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 119:
            // Grammar: ID=119; read/write bits=1; START (TaxRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRule, TaxRuleType (TaxRuleType)); next=120
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule");
                    // decode: element array
                    if (TaxRuleListType->TaxRule.arrayLen < iso20_TaxRuleType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_TaxRuleType(stream, &TaxRuleListType->TaxRule.array[TaxRuleListType->TaxRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_TaxRuleType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 120;

                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 120:
            // Grammar: ID=120; read/write bits=2; LOOP (TaxRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxRule, TaxRuleType (TaxRuleType)); next=120
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule");
                    // decode: element array
                    if (TaxRuleListType->TaxRule.arrayLen < iso20_TaxRuleType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_TaxRuleType(stream, &TaxRuleListType->TaxRule.array[TaxRuleListType->TaxRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_TaxRuleType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (TaxRuleListType->TaxRule.arrayLen < 10)
                    {
                        grammar_id = 120;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStackListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PriceRuleStack, PriceRuleStackType (1, 64) (original max 1024);
static int decode_iso20_PriceRuleStackListType(exi_bitstream_t* stream, struct iso20_PriceRuleStackListType* PriceRuleStackListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 121;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceRuleStackListType(PriceRuleStackListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 121:
            // Grammar: ID=121; read/write bits=1; START (PriceRuleStack)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceRuleStack, PriceRuleStackType (PriceRuleStackType)); next=122
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack");
                    // decode: element array
                    if (PriceRuleStackListType->PriceRuleStack.arrayLen < iso20_PriceRuleStackType_64_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceRuleStackType(stream, &PriceRuleStackListType->PriceRuleStack.array[PriceRuleStackListType->PriceRuleStack.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceRuleStackType_64_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 122;

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 122:
            // Grammar: ID=122; read/write bits=2; LOOP (PriceRuleStack), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (PriceRuleStack, PriceRuleStackType (PriceRuleStackType)); next=122
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack");
                    // decode: element array
                    if (PriceRuleStackListType->PriceRuleStack.arrayLen < iso20_PriceRuleStackType_64_ARRAY_SIZE)
                    {

                        error = decode_iso20_PriceRuleStackType(stream, &PriceRuleStackListType->PriceRuleStack.array[PriceRuleStackListType->PriceRuleStack.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PriceRuleStackType_64_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (PriceRuleStackListType->PriceRuleStack.arrayLen < 1024)
                    {
                        grammar_id = 122;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStack>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}OverstayRules; type={urn:iso:std:iso:15118:-20:CommonMessages}OverstayRuleListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: OverstayTimeThreshold, unsignedInt (0, 1); OverstayPowerThreshold, RationalNumberType (0, 1); OverstayRule, OverstayRuleType (1, 5);
static int decode_iso20_OverstayRuleListType(exi_bitstream_t* stream, struct iso20_OverstayRuleListType* OverstayRuleListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 123;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_OverstayRuleListType(OverstayRuleListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 123:
            // Grammar: ID=123; read/write bits=2; START (OverstayTimeThreshold), START (OverstayPowerThreshold), START (OverstayRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayTimeThreshold, unsignedInt (unsignedLong)); next=125
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayTimeThreshold");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayTimeThreshold");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &OverstayRuleListType->OverstayTimeThreshold);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", OverstayRuleListType->OverstayTimeThreshold);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        OverstayRuleListType->OverstayTimeThreshold_isUsed = 1u;
                        grammar_id = 125;
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayTimeThreshold>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (OverstayPowerThreshold, RationalNumberType (RationalNumberType)); next=127
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &OverstayRuleListType->OverstayPowerThreshold, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        OverstayRuleListType->OverstayPowerThreshold_isUsed = 1u;
                        grammar_id = 127;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (OverstayRule, OverstayRuleType (OverstayRuleType)); next=124
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 124;

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 124:
            // Grammar: ID=124; read/write bits=2; LOOP (OverstayRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (OverstayRule, OverstayRuleType (OverstayRuleType)); next=124
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (OverstayRuleListType->OverstayRule.arrayLen < 5)
                    {
                        grammar_id = 124;
                    }
                    else
                    {
                        grammar_id = 125;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 125:
            // Grammar: ID=125; read/write bits=2; START (OverstayPowerThreshold), START (OverstayRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayPowerThreshold, RationalNumberType (RationalNumberType)); next=127
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &OverstayRuleListType->OverstayPowerThreshold, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        OverstayRuleListType->OverstayPowerThreshold_isUsed = 1u;
                        grammar_id = 127;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayPowerThreshold>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (OverstayRule, OverstayRuleType (OverstayRuleType)); next=126
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 126;

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 126:
            // Grammar: ID=126; read/write bits=2; LOOP (OverstayRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (OverstayRule, OverstayRuleType (OverstayRuleType)); next=126
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (OverstayRuleListType->OverstayRule.arrayLen < 5)
                    {
                        grammar_id = 126;
                    }
                    else
                    {
                        grammar_id = 127;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 127:
            // Grammar: ID=127; read/write bits=1; START (OverstayRule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayRule, OverstayRuleType (OverstayRuleType)); next=128
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 128;

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 128:
            // Grammar: ID=128; read/write bits=2; LOOP (OverstayRule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (OverstayRule, OverstayRuleType (OverstayRuleType)); next=128
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule");
                    // decode: element array
                    if (OverstayRuleListType->OverstayRule.arrayLen < iso20_OverstayRuleType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_OverstayRuleType(stream, &OverstayRuleListType->OverstayRule.array[OverstayRuleListType->OverstayRule.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_OverstayRuleType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (OverstayRuleListType->OverstayRule.arrayLen < 5)
                    {
                        grammar_id = 128;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices; type={urn:iso:std:iso:15118:-20:CommonMessages}AdditionalServiceListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: AdditionalService, AdditionalServiceType (1, 5);
static int decode_iso20_AdditionalServiceListType(exi_bitstream_t* stream, struct iso20_AdditionalServiceListType* AdditionalServiceListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 129;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AdditionalServiceListType(AdditionalServiceListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 129:
            // Grammar: ID=129; read/write bits=1; START (AdditionalService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AdditionalService, AdditionalServiceType (AdditionalServiceType)); next=130
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService");
                    // decode: element array
                    if (AdditionalServiceListType->AdditionalService.arrayLen < iso20_AdditionalServiceType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_AdditionalServiceType(stream, &AdditionalServiceListType->AdditionalService.array[AdditionalServiceListType->AdditionalService.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_AdditionalServiceType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 130;

                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 130:
            // Grammar: ID=130; read/write bits=2; LOOP (AdditionalService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (AdditionalService, AdditionalServiceType (AdditionalServiceType)); next=130
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService");
                    // decode: element array
                    if (AdditionalServiceListType->AdditionalService.arrayLen < iso20_AdditionalServiceType_5_ARRAY_SIZE)
                    {

                        error = decode_iso20_AdditionalServiceType(stream, &AdditionalServiceListType->AdditionalService.array[AdditionalServiceListType->AdditionalService.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_AdditionalServiceType_5_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (AdditionalServiceListType->AdditionalService.arrayLen < 5)
                    {
                        grammar_id = 130;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Service; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceID, serviceIDType (1, 1); FreeService, boolean (1, 1);
static int decode_iso20_ServiceType(exi_bitstream_t* stream, struct iso20_ServiceType* ServiceType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 131;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceType(ServiceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 131:
            // Grammar: ID=131; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=132
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", ServiceType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 132;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 132:
            // Grammar: ID=132; read/write bits=1; START (FreeService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (FreeService, boolean (boolean)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}FreeService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}FreeService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ServiceType->FreeService = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}FreeService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet; type={urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ParameterSetID, serviceIDType (1, 1); Parameter, ParameterType (1, 21) (original max 32);
static int decode_iso20_ParameterSetType(exi_bitstream_t* stream, struct iso20_ParameterSetType* ParameterSetType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 133;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ParameterSetType(ParameterSetType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 133:
            // Grammar: ID=133; read/write bits=1; START (ParameterSetID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSetID, serviceIDType (unsignedShort)); next=134
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ParameterSetType->ParameterSetID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", ParameterSetType->ParameterSetID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 134;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 134:
            // Grammar: ID=134; read/write bits=1; START (Parameter)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Parameter, ParameterType (ParameterType)); next=135
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Parameter");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso20_ParameterType_21_ARRAY_SIZE)
                    {

                        error = decode_iso20_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ParameterType_21_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 135;

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Parameter>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 135:
            // Grammar: ID=135; read/write bits=2; LOOP (Parameter), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Parameter, ParameterType (ParameterType)); next=135
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Parameter");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Parameter");
                    // decode: element array
                    if (ParameterSetType->Parameter.arrayLen < iso20_ParameterType_21_ARRAY_SIZE)
                    {

                        error = decode_iso20_ParameterType(stream, &ParameterSetType->Parameter.array[ParameterSetType->Parameter.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ParameterType_21_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ParameterSetType->Parameter.arrayLen < 32)
                    {
                        grammar_id = 135;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Parameter>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SupportedProviders; type={urn:iso:std:iso:15118:-20:CommonMessages}SupportedProvidersListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ProviderID, nameType (1, 128);
static int decode_iso20_SupportedProvidersListType(exi_bitstream_t* stream, struct iso20_SupportedProvidersListType* SupportedProvidersListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 136;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SupportedProvidersListType(SupportedProvidersListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 136:
            // Grammar: ID=136; read/write bits=1; START (ProviderID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ProviderID, nameType (string)); next=137
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID");
                    // decode: string (len, characters) (Array)
                    if (SupportedProvidersListType->ProviderID.arrayLen < iso20_nameType_128_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                error = exi_basetypes_decoder_uint_16(stream, &SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen);
                                if (error == 0)
                                {
                                    if (SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen >= 2)
                                    {
                                        // string tables and table partitions are not supported, so the length has to be decremented by 2
                                        SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen -= 2;
                                        error = exi_basetypes_decoder_characters(stream, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters, iso20_ProviderID_CHARACTER_SIZE);
                                        if (error == 0)
                                        {
                                            SupportedProvidersListType->ProviderID.arrayLen++;
                                        }
                                        strcat(xmlOut, ">");
                                        if(strlen(xmlOut) + SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                        for(int i = 0; i < SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen; i++) { // check for unprintable characters
                                            if(!isprint(SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters[i]))
                                            {
                                                SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters[i]   = '?';
                                            }
                                        }
                                        strcat(xmlOut, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters);
                                    }
                                    else
                                    {
                                        // the string seems to be in the table, but this is not supported
                                        error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                    }
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 137;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 137:
            // Grammar: ID=137; read/write bits=2; LOOP (ProviderID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (ProviderID, nameType (string)); next=137
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID");
                    // decode: string (len, characters) (Array)
                    if (SupportedProvidersListType->ProviderID.arrayLen < iso20_nameType_128_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                error = exi_basetypes_decoder_uint_16(stream, &SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen);
                                if (error == 0)
                                {
                                    if (SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen >= 2)
                                    {
                                        // string tables and table partitions are not supported, so the length has to be decremented by 2
                                        SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen -= 2;
                                        error = exi_basetypes_decoder_characters(stream, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters, iso20_ProviderID_CHARACTER_SIZE);
                                        if (error == 0)
                                        {
                                            SupportedProvidersListType->ProviderID.arrayLen++;
                                        }
                                        strcat(xmlOut, ">");
                                        if(strlen(xmlOut) + SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                        for(int i = 0; i < SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].charactersLen; i++) { // check for unprintable characters
                                            if(!isprint(SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters[i]))
                                            {
                                                SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters[i]   = '?';
                                            }
                                        }
                                        strcat(xmlOut, SupportedProvidersListType->ProviderID.array[SupportedProvidersListType->ProviderID.arrayLen].characters);
                                    }
                                    else
                                    {
                                        // the string seems to be in the table, but this is not supported
                                        error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                    }
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 137;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ProviderID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain; type={urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChainType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Certificate, certificateType (1, 1); SubCertificates, SubCertificatesType (1, 1);
static int decode_iso20_ContractCertificateChainType(exi_bitstream_t* stream, struct iso20_ContractCertificateChainType* ContractCertificateChainType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 138;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ContractCertificateChainType(ContractCertificateChainType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 138:
            // Grammar: ID=138; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=139
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &ContractCertificateChainType->Certificate.bytesLen, &ContractCertificateChainType->Certificate.bytes[0], iso20_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((ContractCertificateChainType->Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < ContractCertificateChainType->Certificate.bytesLen;) {
                            uint32_t octet_a = i < ContractCertificateChainType->Certificate.bytesLen ? (unsigned char) ContractCertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < ContractCertificateChainType->Certificate.bytesLen ? (unsigned char) ContractCertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < ContractCertificateChainType->Certificate.bytesLen ? (unsigned char) ContractCertificateChainType->Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[ContractCertificateChainType->Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 139;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 139:
            // Grammar: ID=139; read/write bits=1; START (SubCertificates)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SubCertificates, SubCertificatesType (SubCertificatesType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    // decode: element
                    error = decode_iso20_SubCertificatesType(stream, &ContractCertificateChainType->SubCertificates, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_EVPPTControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_EVPPTControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_Dynamic_EVPPTControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_EVPPTControlModeType* Dynamic_EVPPTControlModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)Dynamic_EVPPTControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}MeterInfo; type={urn:iso:std:iso:15118:-20:CommonTypes}MeterInfoType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: MeterID, meterIDType (1, 1); ChargedEnergyReadingWh, unsignedLong (1, 1); BPT_DischargedEnergyReadingWh, unsignedLong (0, 1); CapacitiveEnergyReadingVARh, unsignedLong (0, 1); BPT_InductiveEnergyReadingVARh, unsignedLong (0, 1); MeterSignature, meterSignatureType (0, 1); MeterStatus, short (0, 1); MeterTimestamp, unsignedLong (0, 1);
static int decode_iso20_MeterInfoType(exi_bitstream_t* stream, struct iso20_MeterInfoType* MeterInfoType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 140;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_MeterInfoType(MeterInfoType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 140:
            // Grammar: ID=140; read/write bits=1; START (MeterID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterID, meterIDType (string)); next=141
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &MeterInfoType->MeterID.charactersLen);
                            if (error == 0)
                            {
                                if (MeterInfoType->MeterID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    MeterInfoType->MeterID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, MeterInfoType->MeterID.charactersLen, MeterInfoType->MeterID.characters, iso20_MeterID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + MeterInfoType->MeterID.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < MeterInfoType->MeterID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(MeterInfoType->MeterID.characters[i]))
                                        {
                                            MeterInfoType->MeterID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, MeterInfoType->MeterID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 141;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 141:
            // Grammar: ID=141; read/write bits=1; START (ChargedEnergyReadingWh)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargedEnergyReadingWh, unsignedLong (nonNegativeInteger)); next=142
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ChargedEnergyReadingWh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ChargedEnergyReadingWh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->ChargedEnergyReadingWh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->ChargedEnergyReadingWh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 142;
                    }

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ChargedEnergyReadingWh>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 142:
            // Grammar: ID=142; read/write bits=3; START (BPT_DischargedEnergyReadingWh), START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (BPT_DischargedEnergyReadingWh, unsignedLong (nonNegativeInteger)); next=143
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_DischargedEnergyReadingWh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_DischargedEnergyReadingWh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_DischargedEnergyReadingWh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->BPT_DischargedEnergyReadingWh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->BPT_DischargedEnergyReadingWh_isUsed = 1u;
                        grammar_id = 143;
                    }

                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}BPT_DischargedEnergyReadingWh>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (CapacitiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=144
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->CapacitiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->CapacitiveEnergyReadingVARh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->CapacitiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 144;
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=145
                    if(strlen(xmlOut) + 69 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 145;
                    }

                    if(strlen(xmlOut) + 69 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=146
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->MeterSignature.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->MeterSignature.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->MeterSignature.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 146;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (MeterStatus, short (int)); next=147
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 147;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus>");
                    }
                    break;
                case 5:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 6:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 143:
            // Grammar: ID=143; read/write bits=3; START (CapacitiveEnergyReadingVARh), START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CapacitiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=144
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->CapacitiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->CapacitiveEnergyReadingVARh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->CapacitiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 144;
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}CapacitiveEnergyReadingVARh>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=145
                    if(strlen(xmlOut) + 69 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 145;
                    }

                    if(strlen(xmlOut) + 69 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=146
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->MeterSignature.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->MeterSignature.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->MeterSignature.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 146;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (MeterStatus, short (int)); next=147
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 147;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 5:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 144:
            // Grammar: ID=144; read/write bits=3; START (BPT_InductiveEnergyReadingVARh), START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (BPT_InductiveEnergyReadingVARh, unsignedLong (nonNegativeInteger)); next=145
                    if(strlen(xmlOut) + 69 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->BPT_InductiveEnergyReadingVARh);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->BPT_InductiveEnergyReadingVARh);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->BPT_InductiveEnergyReadingVARh_isUsed = 1u;
                        grammar_id = 145;
                    }

                    if(strlen(xmlOut) + 69 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}BPT_InductiveEnergyReadingVARh>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=146
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->MeterSignature.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->MeterSignature.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->MeterSignature.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 146;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (MeterStatus, short (int)); next=147
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 147;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 145:
            // Grammar: ID=145; read/write bits=3; START (MeterSignature), START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterSignature, meterSignatureType (base64Binary)); next=146
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &MeterInfoType->MeterSignature.bytesLen, &MeterInfoType->MeterSignature.bytes[0], iso20_meterSignatureType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((MeterInfoType->MeterSignature.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < MeterInfoType->MeterSignature.bytesLen;) {
                            uint32_t octet_a = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_b = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            uint32_t octet_c = i < MeterInfoType->MeterSignature.bytesLen ? (unsigned char) MeterInfoType->MeterSignature.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[MeterInfoType->MeterSignature.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        MeterInfoType->MeterSignature_isUsed = 1u;
                        grammar_id = 146;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterSignature>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterStatus, short (int)); next=147
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 147;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 146:
            // Grammar: ID=146; read/write bits=2; START (MeterStatus), START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterStatus, short (int)); next=147
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &MeterInfoType->MeterStatus);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", MeterInfoType->MeterStatus);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        MeterInfoType->MeterStatus_isUsed = 1u;
                        grammar_id = 147;
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 147:
            // Grammar: ID=147; read/write bits=2; START (MeterTimestamp), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterTimestamp, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MeterInfoType->MeterTimestamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MeterInfoType->MeterTimestamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        MeterInfoType->MeterTimestamp_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}MeterTimestamp>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Signature; type={http://www.w3.org/2000/09/xmldsig#}SignatureType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignedInfo, SignedInfoType (1, 1); SignatureValue, SignatureValueType (1, 1); KeyInfo, KeyInfoType (0, 1); Object, ObjectType (0, 1) (original max unbounded);
static int decode_iso20_SignatureType(exi_bitstream_t* stream, struct iso20_SignatureType* SignatureType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 148;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignatureType(SignatureType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 148:
            // Grammar: ID=148; read/write bits=2; START (Id), START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=149
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignatureType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignatureType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignatureType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignatureType->Id.charactersLen, SignatureType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignatureType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignatureType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignatureType->Id.characters[i]))
                                {
                                    SignatureType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignatureType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignatureType->Id_isUsed = 1u;
                    grammar_id = 149;

                    }
                    break;
                case 1:
                    {
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=150
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    // decode: element
                    error = decode_iso20_SignedInfoType(stream, &SignatureType->SignedInfo, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 150;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 149:
            // Grammar: ID=149; read/write bits=1; START (SignedInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignedInfo, SignedInfoType (SignedInfoType)); next=150
                    if(strlen(xmlOut) + 46 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignedInfo");
                    // decode: element
                    error = decode_iso20_SignedInfoType(stream, &SignatureType->SignedInfo, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 150;
                    }


                    if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 150:
            // Grammar: ID=150; read/write bits=1; START (SignatureValue)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureValue, SignatureValueType (base64Binary)); next=151
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureValue");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureValue");
                    // decode: element
                    error = decode_iso20_SignatureValueType(stream, &SignatureType->SignatureValue, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 151;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureValue>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 151:
            // Grammar: ID=151; read/write bits=2; START (KeyInfo), START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (KeyInfo, KeyInfoType (KeyInfoType)); next=153
                    if(strlen(xmlOut) + 43 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyInfo");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}KeyInfo");
                    // decode: element
                    error = decode_iso20_KeyInfoType(stream, &SignatureType->KeyInfo, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignatureType->KeyInfo_isUsed = 1u;
                        grammar_id = 153;
                    }


                    if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyInfo>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=152
                    if(strlen(xmlOut) + 42 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso20_ObjectType(stream, &SignatureType->Object, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 152;
                    }


                    if(strlen(xmlOut) + 42 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 152:
            // Grammar: ID=152; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=2
                    if(strlen(xmlOut) + 42 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;

                    if(strlen(xmlOut) + 42 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 153:
            // Grammar: ID=153; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=154
                    if(strlen(xmlOut) + 42 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    error = decode_iso20_ObjectType(stream, &SignatureType->Object, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignatureType->Object_isUsed = 1u;
                        grammar_id = 154;
                    }


                    if(strlen(xmlOut) + 42 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 154:
            // Grammar: ID=154; read/write bits=2; START (Object), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Object, ObjectType (ObjectType)); next=2
                    if(strlen(xmlOut) + 42 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Object");
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;

                    if(strlen(xmlOut) + 42 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_EVPPTControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_EVPPTControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SelectedScheduleTupleID, numericIDType (1, 1); PowerToleranceAcceptance, powerToleranceAcceptanceType (0, 1);
static int decode_iso20_Scheduled_EVPPTControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_EVPPTControlModeType* Scheduled_EVPPTControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 155;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Scheduled_EVPPTControlModeType(Scheduled_EVPPTControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 155:
            // Grammar: ID=155; read/write bits=1; START (SelectedScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedScheduleTupleID, numericIDType (unsignedInt)); next=156
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Scheduled_EVPPTControlModeType->SelectedScheduleTupleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", Scheduled_EVPPTControlModeType->SelectedScheduleTupleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 156;
                    }

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 156:
            // Grammar: ID=156; read/write bits=2; START (PowerToleranceAcceptance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerToleranceAcceptance, powerToleranceAcceptanceType (string)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerToleranceAcceptance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerToleranceAcceptance");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                Scheduled_EVPPTControlModeType->PowerToleranceAcceptance = (iso20_powerToleranceAcceptanceType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_powerToleranceAcceptanceType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_powerToleranceAcceptanceType_reverse(value));
                                Scheduled_EVPPTControlModeType->PowerToleranceAcceptance_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerToleranceAcceptance>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Receipt; type={urn:iso:std:iso:15118:-20:CommonTypes}ReceiptType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); EnergyCosts, DetailedCostType (0, 1); OccupancyCosts, DetailedCostType (0, 1); AdditionalServicesCosts, DetailedCostType (0, 1); OverstayCosts, DetailedCostType (0, 1); TaxCosts, DetailedTaxType (0, 10);
static int decode_iso20_ReceiptType(exi_bitstream_t* stream, struct iso20_ReceiptType* ReceiptType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 157;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ReceiptType(ReceiptType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 157:
            // Grammar: ID=157; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=158
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &ReceiptType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", ReceiptType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 158;
                    }

                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 158:
            // Grammar: ID=158; read/write bits=3; START (EnergyCosts), START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyCosts, DetailedCostType (DetailedCostType)); next=160
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->EnergyCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->EnergyCosts_isUsed = 1u;
                        grammar_id = 160;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}EnergyCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (OccupancyCosts, DetailedCostType (DetailedCostType)); next=162
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OccupancyCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OccupancyCosts_isUsed = 1u;
                        grammar_id = 162;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=164
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 164;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=166
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OverstayCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 166;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=159
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 159;

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 5:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 159:
            // Grammar: ID=159; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=159
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 159;
                    }
                    else
                    {
                        grammar_id = 160;
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 160:
            // Grammar: ID=160; read/write bits=3; START (OccupancyCosts), START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OccupancyCosts, DetailedCostType (DetailedCostType)); next=162
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OccupancyCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OccupancyCosts_isUsed = 1u;
                        grammar_id = 162;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OccupancyCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=164
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 164;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=166
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OverstayCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 166;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=161
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 161;

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 161:
            // Grammar: ID=161; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=161
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 161;
                    }
                    else
                    {
                        grammar_id = 162;
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 162:
            // Grammar: ID=162; read/write bits=3; START (AdditionalServicesCosts), START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AdditionalServicesCosts, DetailedCostType (DetailedCostType)); next=164
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->AdditionalServicesCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->AdditionalServicesCosts_isUsed = 1u;
                        grammar_id = 164;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}AdditionalServicesCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=166
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OverstayCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 166;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=163
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 163;

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 163:
            // Grammar: ID=163; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=163
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 163;
                    }
                    else
                    {
                        grammar_id = 164;
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 164:
            // Grammar: ID=164; read/write bits=2; START (OverstayCosts), START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayCosts, DetailedCostType (DetailedCostType)); next=166
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts");
                    // decode: element
                    error = decode_iso20_DetailedCostType(stream, &ReceiptType->OverstayCosts, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ReceiptType->OverstayCosts_isUsed = 1u;
                        grammar_id = 166;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}OverstayCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=165
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 165;

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 165:
            // Grammar: ID=165; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=165
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 165;
                    }
                    else
                    {
                        grammar_id = 166;
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 166:
            // Grammar: ID=166; read/write bits=2; START (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxCosts, DetailedTaxType (DetailedTaxType)); next=167
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 167;

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 167:
            // Grammar: ID=167; read/write bits=2; LOOP (TaxCosts), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (TaxCosts, DetailedTaxType (DetailedTaxType)); next=167
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts");
                    // decode: element array
                    if (ReceiptType->TaxCosts.arrayLen < iso20_DetailedTaxType_10_ARRAY_SIZE)
                    {

                        error = decode_iso20_DetailedTaxType(stream, &ReceiptType->TaxCosts.array[ReceiptType->TaxCosts.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_DetailedTaxType_10_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ReceiptType->TaxCosts.arrayLen < 10)
                    {
                        grammar_id = 167;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TaxCosts>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceScheduleType; base type=PriceScheduleType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); TimeAnchor, unsignedLong (1, 1); PriceScheduleID, numericIDType (1, 1); PriceScheduleDescription, descriptionType (0, 1); Currency, currencyType (1, 1); Language, languageType (1, 1); PriceAlgorithm, identifierType (1, 1); MinimumCost, RationalNumberType (0, 1); MaximumCost, RationalNumberType (0, 1); TaxRules, TaxRuleListType (0, 1); PriceRuleStacks, PriceRuleStackListType (1, 1); OverstayRules, OverstayRuleListType (0, 1); AdditionalSelectedServices, AdditionalServiceListType (0, 1);
static int decode_iso20_AbsolutePriceScheduleType(exi_bitstream_t* stream, struct iso20_AbsolutePriceScheduleType* AbsolutePriceScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 168;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AbsolutePriceScheduleType(AbsolutePriceScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 168:
            // Grammar: ID=168; read/write bits=2; START (Id), START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=169
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (AbsolutePriceScheduleType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            AbsolutePriceScheduleType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->Id.charactersLen, AbsolutePriceScheduleType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + AbsolutePriceScheduleType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < AbsolutePriceScheduleType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(AbsolutePriceScheduleType->Id.characters[i]))
                                {
                                    AbsolutePriceScheduleType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, AbsolutePriceScheduleType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    AbsolutePriceScheduleType->Id_isUsed = 1u;
                    grammar_id = 169;

                    }
                    break;
                case 1:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=170
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &AbsolutePriceScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", AbsolutePriceScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 170;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 169:
            // Grammar: ID=169; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=170
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &AbsolutePriceScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", AbsolutePriceScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 170;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 170:
            // Grammar: ID=170; read/write bits=1; START (PriceScheduleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceScheduleID, numericIDType (unsignedInt)); next=171
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &AbsolutePriceScheduleType->PriceScheduleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", AbsolutePriceScheduleType->PriceScheduleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 171;
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 171:
            // Grammar: ID=171; read/write bits=2; START (PriceScheduleDescription), START (Currency)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceScheduleDescription, descriptionType (string)); next=172
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen);
                            if (error == 0)
                            {
                                if (AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen, AbsolutePriceScheduleType->PriceScheduleDescription.characters, iso20_PriceScheduleDescription_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AbsolutePriceScheduleType->PriceScheduleDescription.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AbsolutePriceScheduleType->PriceScheduleDescription.characters[i]))
                                        {
                                            AbsolutePriceScheduleType->PriceScheduleDescription.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AbsolutePriceScheduleType->PriceScheduleDescription.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                AbsolutePriceScheduleType->PriceScheduleDescription_isUsed = 1u;
                                grammar_id = 172;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Currency, currencyType (string)); next=173
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->Currency.charactersLen);
                            if (error == 0)
                            {
                                if (AbsolutePriceScheduleType->Currency.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AbsolutePriceScheduleType->Currency.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->Currency.charactersLen, AbsolutePriceScheduleType->Currency.characters, iso20_Currency_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AbsolutePriceScheduleType->Currency.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AbsolutePriceScheduleType->Currency.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AbsolutePriceScheduleType->Currency.characters[i]))
                                        {
                                            AbsolutePriceScheduleType->Currency.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AbsolutePriceScheduleType->Currency.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 173;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Currency>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 172:
            // Grammar: ID=172; read/write bits=1; START (Currency)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Currency, currencyType (string)); next=173
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Currency");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->Currency.charactersLen);
                            if (error == 0)
                            {
                                if (AbsolutePriceScheduleType->Currency.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AbsolutePriceScheduleType->Currency.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->Currency.charactersLen, AbsolutePriceScheduleType->Currency.characters, iso20_Currency_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AbsolutePriceScheduleType->Currency.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AbsolutePriceScheduleType->Currency.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AbsolutePriceScheduleType->Currency.characters[i]))
                                        {
                                            AbsolutePriceScheduleType->Currency.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AbsolutePriceScheduleType->Currency.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 173;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Currency>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 173:
            // Grammar: ID=173; read/write bits=1; START (Language)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Language, languageType (string)); next=174
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Language");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Language");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->Language.charactersLen);
                            if (error == 0)
                            {
                                if (AbsolutePriceScheduleType->Language.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AbsolutePriceScheduleType->Language.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->Language.charactersLen, AbsolutePriceScheduleType->Language.characters, iso20_Language_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AbsolutePriceScheduleType->Language.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AbsolutePriceScheduleType->Language.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AbsolutePriceScheduleType->Language.characters[i]))
                                        {
                                            AbsolutePriceScheduleType->Language.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AbsolutePriceScheduleType->Language.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 174;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Language>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 174:
            // Grammar: ID=174; read/write bits=1; START (PriceAlgorithm)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceAlgorithm, identifierType (string)); next=175
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &AbsolutePriceScheduleType->PriceAlgorithm.charactersLen);
                            if (error == 0)
                            {
                                if (AbsolutePriceScheduleType->PriceAlgorithm.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    AbsolutePriceScheduleType->PriceAlgorithm.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, AbsolutePriceScheduleType->PriceAlgorithm.charactersLen, AbsolutePriceScheduleType->PriceAlgorithm.characters, iso20_PriceAlgorithm_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + AbsolutePriceScheduleType->PriceAlgorithm.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < AbsolutePriceScheduleType->PriceAlgorithm.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(AbsolutePriceScheduleType->PriceAlgorithm.characters[i]))
                                        {
                                            AbsolutePriceScheduleType->PriceAlgorithm.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, AbsolutePriceScheduleType->PriceAlgorithm.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 175;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceAlgorithm>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 175:
            // Grammar: ID=175; read/write bits=3; START (MinimumCost), START (MaximumCost), START (TaxRules), START (PriceRuleStacks)
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MinimumCost, RationalNumberType (RationalNumberType)); next=176
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumCost");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumCost");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &AbsolutePriceScheduleType->MinimumCost, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->MinimumCost_isUsed = 1u;
                        grammar_id = 176;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MinimumCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MaximumCost, RationalNumberType (RationalNumberType)); next=177
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &AbsolutePriceScheduleType->MaximumCost, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->MaximumCost_isUsed = 1u;
                        grammar_id = 177;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TaxRules, TaxRuleListType (TaxRuleListType)); next=178
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    // decode: element
                    error = decode_iso20_TaxRuleListType(stream, &AbsolutePriceScheduleType->TaxRules, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->TaxRules_isUsed = 1u;
                        grammar_id = 178;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (PriceRuleStacks, PriceRuleStackListType (PriceRuleStackListType)); next=179
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    // decode: element
                    error = decode_iso20_PriceRuleStackListType(stream, &AbsolutePriceScheduleType->PriceRuleStacks, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 179;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 176:
            // Grammar: ID=176; read/write bits=2; START (MaximumCost), START (TaxRules), START (PriceRuleStacks)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MaximumCost, RationalNumberType (RationalNumberType)); next=177
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &AbsolutePriceScheduleType->MaximumCost, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->MaximumCost_isUsed = 1u;
                        grammar_id = 177;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MaximumCost>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TaxRules, TaxRuleListType (TaxRuleListType)); next=178
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    // decode: element
                    error = decode_iso20_TaxRuleListType(stream, &AbsolutePriceScheduleType->TaxRules, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->TaxRules_isUsed = 1u;
                        grammar_id = 178;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (PriceRuleStacks, PriceRuleStackListType (PriceRuleStackListType)); next=179
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    // decode: element
                    error = decode_iso20_PriceRuleStackListType(stream, &AbsolutePriceScheduleType->PriceRuleStacks, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 179;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 177:
            // Grammar: ID=177; read/write bits=2; START (TaxRules), START (PriceRuleStacks)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TaxRules, TaxRuleListType (TaxRuleListType)); next=178
                    if(strlen(xmlOut) + 50 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules");
                    // decode: element
                    error = decode_iso20_TaxRuleListType(stream, &AbsolutePriceScheduleType->TaxRules, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->TaxRules_isUsed = 1u;
                        grammar_id = 178;
                    }


                    if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TaxRules>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PriceRuleStacks, PriceRuleStackListType (PriceRuleStackListType)); next=179
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    // decode: element
                    error = decode_iso20_PriceRuleStackListType(stream, &AbsolutePriceScheduleType->PriceRuleStacks, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 179;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 178:
            // Grammar: ID=178; read/write bits=1; START (PriceRuleStacks)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceRuleStacks, PriceRuleStackListType (PriceRuleStackListType)); next=179
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks");
                    // decode: element
                    error = decode_iso20_PriceRuleStackListType(stream, &AbsolutePriceScheduleType->PriceRuleStacks, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 179;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceRuleStacks>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 179:
            // Grammar: ID=179; read/write bits=2; START (OverstayRules), START (AdditionalSelectedServices), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OverstayRules, OverstayRuleListType (OverstayRuleListType)); next=180
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRules");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRules");
                    // decode: element
                    error = decode_iso20_OverstayRuleListType(stream, &AbsolutePriceScheduleType->OverstayRules, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->OverstayRules_isUsed = 1u;
                        grammar_id = 180;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OverstayRules>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AdditionalSelectedServices, AdditionalServiceListType (AdditionalServiceListType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices");
                    // decode: element
                    error = decode_iso20_AdditionalServiceListType(stream, &AbsolutePriceScheduleType->AdditionalSelectedServices, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->AdditionalSelectedServices_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 180:
            // Grammar: ID=180; read/write bits=2; START (AdditionalSelectedServices), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AdditionalSelectedServices, AdditionalServiceListType (AdditionalServiceListType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices");
                    // decode: element
                    error = decode_iso20_AdditionalServiceListType(stream, &AbsolutePriceScheduleType->AdditionalSelectedServices, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AbsolutePriceScheduleType->AdditionalSelectedServices_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AdditionalSelectedServices>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntries; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntryListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVPowerProfileEntry, PowerScheduleEntryType (1, 2048);
static int decode_iso20_EVPowerProfileEntryListType(exi_bitstream_t* stream, struct iso20_EVPowerProfileEntryListType* EVPowerProfileEntryListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 181;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPowerProfileEntryListType(EVPowerProfileEntryListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 181:
            // Grammar: ID=181; read/write bits=1; START (EVPowerProfileEntry)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerProfileEntry, PowerScheduleEntryType (PowerScheduleEntryType)); next=182
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry");
                    // decode: element array
                    if (EVPowerProfileEntryListType->EVPowerProfileEntry.arrayLen < iso20_PowerScheduleEntryType_2048_ARRAY_SIZE)
                    {

                        error = decode_iso20_PowerScheduleEntryType(stream, &EVPowerProfileEntryListType->EVPowerProfileEntry.array[EVPowerProfileEntryListType->EVPowerProfileEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PowerScheduleEntryType_2048_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 182;

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 182:
            // Grammar: ID=182; read/write bits=2; LOOP (EVPowerProfileEntry), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (EVPowerProfileEntry, PowerScheduleEntryType (PowerScheduleEntryType)); next=182
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry");
                    // decode: element array
                    if (EVPowerProfileEntryListType->EVPowerProfileEntry.arrayLen < iso20_PowerScheduleEntryType_2048_ARRAY_SIZE)
                    {

                        error = decode_iso20_PowerScheduleEntryType(stream, &EVPowerProfileEntryListType->EVPowerProfileEntry.array[EVPowerProfileEntryListType->EVPowerProfileEntry.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_PowerScheduleEntryType_2048_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (EVPowerProfileEntryListType->EVPowerProfileEntry.arrayLen < 2048)
                    {
                        grammar_id = 182;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntry>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_Dynamic_SMDTControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SMDTControlModeType* Dynamic_SMDTControlModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)Dynamic_SMDTControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer; type={urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOfferType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EVPowerSchedule, EVPowerScheduleType (1, 1); EVAbsolutePriceSchedule, EVAbsolutePriceScheduleType (1, 1);
static int decode_iso20_EVEnergyOfferType(exi_bitstream_t* stream, struct iso20_EVEnergyOfferType* EVEnergyOfferType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 183;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVEnergyOfferType(EVEnergyOfferType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 183:
            // Grammar: ID=183; read/write bits=1; START (EVPowerSchedule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerSchedule, EVPowerScheduleType (EVPowerScheduleType)); next=184
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerSchedule");
                    // decode: element
                    error = decode_iso20_EVPowerScheduleType(stream, &EVEnergyOfferType->EVPowerSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 184;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerSchedule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 184:
            // Grammar: ID=184; read/write bits=1; START (EVAbsolutePriceSchedule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVAbsolutePriceSchedule, EVAbsolutePriceScheduleType (EVAbsolutePriceScheduleType)); next=2
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVAbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVAbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_EVAbsolutePriceScheduleType(stream, &EVEnergyOfferType->EVAbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVAbsolutePriceSchedule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleType; base type=PriceScheduleType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Id, ID (0, 1); TimeAnchor, unsignedLong (1, 1); PriceScheduleID, numericIDType (1, 1); PriceScheduleDescription, descriptionType (0, 1); NumberOfPriceLevels, unsignedByte (1, 1); PriceLevelScheduleEntries, PriceLevelScheduleEntryListType (1, 1);
static int decode_iso20_PriceLevelScheduleType(exi_bitstream_t* stream, struct iso20_PriceLevelScheduleType* PriceLevelScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 185;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PriceLevelScheduleType(PriceLevelScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 185:
            // Grammar: ID=185; read/write bits=2; START (Id), START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=186
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &PriceLevelScheduleType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (PriceLevelScheduleType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            PriceLevelScheduleType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, PriceLevelScheduleType->Id.charactersLen, PriceLevelScheduleType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + PriceLevelScheduleType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < PriceLevelScheduleType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(PriceLevelScheduleType->Id.characters[i]))
                                {
                                    PriceLevelScheduleType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, PriceLevelScheduleType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    PriceLevelScheduleType->Id_isUsed = 1u;
                    grammar_id = 186;

                    }
                    break;
                case 1:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=187
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &PriceLevelScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", PriceLevelScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 187;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 186:
            // Grammar: ID=186; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=187
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &PriceLevelScheduleType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", PriceLevelScheduleType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 187;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 187:
            // Grammar: ID=187; read/write bits=1; START (PriceScheduleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceScheduleID, numericIDType (unsignedInt)); next=188
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &PriceLevelScheduleType->PriceScheduleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", PriceLevelScheduleType->PriceScheduleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 188;
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 188:
            // Grammar: ID=188; read/write bits=2; START (PriceScheduleDescription), START (NumberOfPriceLevels)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceScheduleDescription, descriptionType (string)); next=189
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &PriceLevelScheduleType->PriceScheduleDescription.charactersLen);
                            if (error == 0)
                            {
                                if (PriceLevelScheduleType->PriceScheduleDescription.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    PriceLevelScheduleType->PriceScheduleDescription.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, PriceLevelScheduleType->PriceScheduleDescription.charactersLen, PriceLevelScheduleType->PriceScheduleDescription.characters, iso20_PriceScheduleDescription_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + PriceLevelScheduleType->PriceScheduleDescription.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < PriceLevelScheduleType->PriceScheduleDescription.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(PriceLevelScheduleType->PriceScheduleDescription.characters[i]))
                                        {
                                            PriceLevelScheduleType->PriceScheduleDescription.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, PriceLevelScheduleType->PriceScheduleDescription.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                PriceLevelScheduleType->PriceScheduleDescription_isUsed = 1u;
                                grammar_id = 189;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceScheduleDescription>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (NumberOfPriceLevels, unsignedByte (unsignedShort)); next=190
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceLevelScheduleType->NumberOfPriceLevels = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceLevelScheduleType->NumberOfPriceLevels);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 190;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 189:
            // Grammar: ID=189; read/write bits=1; START (NumberOfPriceLevels)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (NumberOfPriceLevels, unsignedByte (unsignedShort)); next=190
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                PriceLevelScheduleType->NumberOfPriceLevels = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", PriceLevelScheduleType->NumberOfPriceLevels);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 190;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}NumberOfPriceLevels>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 190:
            // Grammar: ID=190; read/write bits=1; START (PriceLevelScheduleEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PriceLevelScheduleEntries, PriceLevelScheduleEntryListType (PriceLevelScheduleEntryListType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntries");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleEntryListType(stream, &PriceLevelScheduleType->PriceLevelScheduleEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelScheduleEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ChargingSchedule; type={urn:iso:std:iso:15118:-20:CommonMessages}ChargingScheduleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: PowerSchedule, PowerScheduleType (1, 1); AbsolutePriceSchedule, AbsolutePriceScheduleType (0, 1); PriceLevelSchedule, PriceLevelScheduleType (0, 1);
static int decode_iso20_ChargingScheduleType(exi_bitstream_t* stream, struct iso20_ChargingScheduleType* ChargingScheduleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 191;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ChargingScheduleType(ChargingScheduleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 191:
            // Grammar: ID=191; read/write bits=1; START (PowerSchedule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PowerSchedule, PowerScheduleType (PowerScheduleType)); next=192
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PowerSchedule");
                    // decode: element
                    error = decode_iso20_PowerScheduleType(stream, &ChargingScheduleType->PowerSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 192;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerSchedule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 192:
            // Grammar: ID=192; read/write bits=2; START (AbsolutePriceSchedule), START (PriceLevelSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AbsolutePriceSchedule, AbsolutePriceScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_AbsolutePriceScheduleType(stream, &ChargingScheduleType->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ChargingScheduleType->AbsolutePriceSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PriceLevelSchedule, PriceLevelScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleType(stream, &ChargingScheduleType->PriceLevelSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ChargingScheduleType->PriceLevelSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple; type={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTupleType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ScheduleTupleID, numericIDType (1, 1); ChargingSchedule, ChargingScheduleType (1, 1); DischargingSchedule, ChargingScheduleType (0, 1);
static int decode_iso20_ScheduleTupleType(exi_bitstream_t* stream, struct iso20_ScheduleTupleType* ScheduleTupleType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 193;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ScheduleTupleType(ScheduleTupleType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 193:
            // Grammar: ID=193; read/write bits=1; START (ScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ScheduleTupleID, numericIDType (unsignedInt)); next=194
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTupleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &ScheduleTupleType->ScheduleTupleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", ScheduleTupleType->ScheduleTupleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 194;
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 194:
            // Grammar: ID=194; read/write bits=1; START (ChargingSchedule)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingSchedule, ChargingScheduleType (ChargingScheduleType)); next=195
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSchedule");
                    // decode: element
                    error = decode_iso20_ChargingScheduleType(stream, &ScheduleTupleType->ChargingSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 195;
                    }


                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSchedule>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 195:
            // Grammar: ID=195; read/write bits=2; START (DischargingSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DischargingSchedule, ChargingScheduleType (ChargingScheduleType)); next=2
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DischargingSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DischargingSchedule");
                    // decode: element
                    error = decode_iso20_ChargingScheduleType(stream, &ScheduleTupleType->DischargingSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleTupleType->DischargingSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DischargingSchedule>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SelectedScheduleTupleID, numericIDType (1, 1);
static int decode_iso20_Scheduled_SMDTControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SMDTControlModeType* Scheduled_SMDTControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 196;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Scheduled_SMDTControlModeType(Scheduled_SMDTControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 196:
            // Grammar: ID=196; read/write bits=1; START (SelectedScheduleTupleID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedScheduleTupleID, numericIDType (unsignedInt)); next=2
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Scheduled_SMDTControlModeType->SelectedScheduleTupleID);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", Scheduled_SMDTControlModeType->SelectedScheduleTupleID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedScheduleTupleID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}Header; type={urn:iso:std:iso:15118:-20:CommonTypes}MessageHeaderType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SessionID, sessionIDType (1, 1); TimeStamp, unsignedLong (1, 1); Signature, SignatureType (0, 1);
static int decode_iso20_MessageHeaderType(exi_bitstream_t* stream, struct iso20_MessageHeaderType* MessageHeaderType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 197;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_MessageHeaderType(MessageHeaderType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 197:
            // Grammar: ID=197; read/write bits=1; START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=198
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}SessionID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}SessionID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &MessageHeaderType->SessionID.bytesLen, &MessageHeaderType->SessionID.bytes[0], iso20_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        if(strlen(xmlOut) + 128 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &MessageHeaderType->SessionID.bytes[0];
                        uint16_t len = MessageHeaderType->SessionID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 198;
                    }

                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}SessionID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 198:
            // Grammar: ID=198; read/write bits=1; START (TimeStamp)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeStamp, unsignedLong (nonNegativeInteger)); next=199
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}TimeStamp");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}TimeStamp");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &MessageHeaderType->TimeStamp);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", MessageHeaderType->TimeStamp);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 199;
                    }

                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}TimeStamp>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 199:
            // Grammar: ID=199; read/write bits=2; START (Signature), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Signature, SignatureType (SignatureType)); next=2
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Signature");
                    // decode: element
                    error = decode_iso20_SignatureType(stream, &MessageHeaderType->Signature, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        MessageHeaderType->Signature_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Signature>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperty; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertyType; base type=; content type=mixed;
//          abstract=False; final=False; choice=True;
// Particle: Id, ID (0, 1); Target, anyURI (1, 1); ANY, anyType (0, 1);
static int decode_iso20_SignaturePropertyType(exi_bitstream_t* stream, struct iso20_SignaturePropertyType* SignaturePropertyType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 200;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignaturePropertyType(SignaturePropertyType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 200:
            // Grammar: ID=200; read/write bits=2; START (Id), START (Target)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=201
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Id.charactersLen, SignaturePropertyType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignaturePropertyType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignaturePropertyType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignaturePropertyType->Id.characters[i]))
                                {
                                    SignaturePropertyType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignaturePropertyType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignaturePropertyType->Id_isUsed = 1u;
                    grammar_id = 201;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Target, anyURI (anyURI)); next=202
                    if(strlen(xmlOut) + 6 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Target");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Target.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Target.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Target.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_Target_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignaturePropertyType->Target.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignaturePropertyType->Target.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignaturePropertyType->Target.characters[i]))
                                {
                                    SignaturePropertyType->Target.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignaturePropertyType->Target.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 202;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 201:
            // Grammar: ID=201; read/write bits=1; START (Target)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Target, anyURI (anyURI)); next=202
                    if(strlen(xmlOut) + 6 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Target");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertyType->Target.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertyType->Target.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertyType->Target.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertyType->Target.charactersLen, SignaturePropertyType->Target.characters, iso20_Target_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignaturePropertyType->Target.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignaturePropertyType->Target.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignaturePropertyType->Target.characters[i]))
                                {
                                    SignaturePropertyType->Target.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignaturePropertyType->Target.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 202;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 202:
            // Grammar: ID=202; read/write bits=1; START (ANY)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ANY, anyType (base64Binary)); next=2
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignaturePropertyType->ANY.bytesLen, &SignaturePropertyType->ANY.bytes[0], iso20_anyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignaturePropertyType->ANY.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignaturePropertyType->ANY.bytesLen;) {
                            uint32_t octet_a = i < SignaturePropertyType->ANY.bytesLen ? (unsigned char) SignaturePropertyType->ANY.bytes[i++] : 0;
                            uint32_t octet_b = i < SignaturePropertyType->ANY.bytesLen ? (unsigned char) SignaturePropertyType->ANY.bytes[i++] : 0;
                            uint32_t octet_c = i < SignaturePropertyType->ANY.bytesLen ? (unsigned char) SignaturePropertyType->ANY.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignaturePropertyType->ANY.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignaturePropertyType->ANY_isUsed = 1u;
                        grammar_id = 2;
                    }



                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SupportedServiceIDs; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceIDListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceID, serviceIDType (1, 16);
static int decode_iso20_ServiceIDListType(exi_bitstream_t* stream, struct iso20_ServiceIDListType* ServiceIDListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 203;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceIDListType(ServiceIDListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 203:
            // Grammar: ID=203; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=204
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short array
                    if (ServiceIDListType->ServiceID.arrayLen < iso20_serviceIDType_16_ARRAY_SIZE)
                    {
                        error = decode_exi_type_uint16(stream, &ServiceIDListType->ServiceID.array[ServiceIDListType->ServiceID.arrayLen++]);
                        if (error == 0)
                        {
                            char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                            if(strlen(xmlOut) + 6 + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            sprintf(append, "%u", ServiceIDListType->ServiceID.array[ServiceIDListType->ServiceID.arrayLen - 1]);
                            strcat(xmlOut, ">");
                            strcat(xmlOut, append);
                        }
                    }
                    else
                    {
                        // static array not large enough, only iso20_serviceIDType_16_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 204;

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 204:
            // Grammar: ID=204; read/write bits=2; LOOP (ServiceID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (ServiceID, serviceIDType (unsignedShort)); next=204
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short array
                    if (ServiceIDListType->ServiceID.arrayLen < iso20_serviceIDType_16_ARRAY_SIZE)
                    {
                        error = decode_exi_type_uint16(stream, &ServiceIDListType->ServiceID.array[ServiceIDListType->ServiceID.arrayLen++]);
                        if (error == 0)
                        {
                            char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                            if(strlen(xmlOut) + 6 + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            sprintf(append, "%u", ServiceIDListType->ServiceID.array[ServiceIDListType->ServiceID.arrayLen - 1]);
                            strcat(xmlOut, ">");
                            strcat(xmlOut, append);
                        }
                    }
                    else
                    {
                        // static array not large enough, only iso20_serviceIDType_16_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 204;

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SelectedEnergyTransferService; type={urn:iso:std:iso:15118:-20:CommonMessages}SelectedServiceType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ServiceID, serviceIDType (1, 1); ParameterSetID, serviceIDType (1, 1);
static int decode_iso20_SelectedServiceType(exi_bitstream_t* stream, struct iso20_SelectedServiceType* SelectedServiceType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 205;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SelectedServiceType(SelectedServiceType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 205:
            // Grammar: ID=205; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=206
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &SelectedServiceType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", SelectedServiceType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 206;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 206:
            // Grammar: ID=206; read/write bits=1; START (ParameterSetID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSetID, serviceIDType (unsignedShort)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &SelectedServiceType->ParameterSetID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", SelectedServiceType->ParameterSetID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSetID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData; type={urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (1, 1); SessionID, sessionIDType (1, 1); MeterInfo, MeterInfoType (1, 1); Receipt, ReceiptType (0, 1); Dynamic_SMDTControlMode, Dynamic_SMDTControlModeType (0, 1); Scheduled_SMDTControlMode, Scheduled_SMDTControlModeType (0, 1);
static int decode_iso20_SignedMeteringDataType(exi_bitstream_t* stream, struct iso20_SignedMeteringDataType* SignedMeteringDataType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 207;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignedMeteringDataType(SignedMeteringDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 207:
            // Grammar: ID=207; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=208
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedMeteringDataType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedMeteringDataType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedMeteringDataType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedMeteringDataType->Id.charactersLen, SignedMeteringDataType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignedMeteringDataType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignedMeteringDataType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignedMeteringDataType->Id.characters[i]))
                                {
                                    SignedMeteringDataType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignedMeteringDataType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 208;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 208:
            // Grammar: ID=208; read/write bits=1; START (SessionID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SessionID, sessionIDType (hexBinary)); next=209
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SessionID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SessionID");
                    // decode exi type: hexBinary
                    error = decode_exi_type_hex_binary(stream, &SignedMeteringDataType->SessionID.bytesLen, &SignedMeteringDataType->SessionID.bytes[0], iso20_sessionIDType_BYTES_SIZE);
                    if (error == 0)
                    {
                        if(strlen(xmlOut) + 128 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        char asHex[128] = "";
                        char* ahPtr = &asHex[0];
                        uint8_t* contentPtr = &SignedMeteringDataType->SessionID.bytes[0];
                        uint16_t len = SignedMeteringDataType->SessionID.bytesLen;
                        if(len * 2 + 1 > 128) {  error = -2; strcat(xmlOut, "DECODE_ERROR"); break; }
                        while(len--) {
                          sprintf(ahPtr, "%02X", *contentPtr);
                          ahPtr += 2;
                          ++contentPtr;
                        }
                        *ahPtr = 0;
                        strcat(xmlOut, ">");
                        strcat(xmlOut, asHex);
                        grammar_id = 209;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SessionID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 209:
            // Grammar: ID=209; read/write bits=1; START (MeterInfo)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MeterInfo, MeterInfoType (MeterInfoType)); next=210
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MeterInfo");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MeterInfo");
                    // decode: element
                    error = decode_iso20_MeterInfoType(stream, &SignedMeteringDataType->MeterInfo, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 210;
                    }


                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MeterInfo>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 210:
            // Grammar: ID=210; read/write bits=2; START (Receipt), START (Dynamic_SMDTControlMode), START (Scheduled_SMDTControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Receipt, ReceiptType (ReceiptType)); next=211
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Receipt");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Receipt");
                    // decode: element
                    error = decode_iso20_ReceiptType(stream, &SignedMeteringDataType->Receipt, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedMeteringDataType->Receipt_isUsed = 1u;
                        grammar_id = 211;
                    }


                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Receipt>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Dynamic_SMDTControlMode, Dynamic_SMDTControlModeType (Dynamic_SMDTControlModeType)); next=2
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_SMDTControlModeType(stream, &SignedMeteringDataType->Dynamic_SMDTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedMeteringDataType->Dynamic_SMDTControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (Scheduled_SMDTControlMode, Scheduled_SMDTControlModeType (Scheduled_SMDTControlModeType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_SMDTControlModeType(stream, &SignedMeteringDataType->Scheduled_SMDTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedMeteringDataType->Scheduled_SMDTControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 211:
            // Grammar: ID=211; read/write bits=2; START (Dynamic_SMDTControlMode), START (Scheduled_SMDTControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Dynamic_SMDTControlMode, Dynamic_SMDTControlModeType (Dynamic_SMDTControlModeType)); next=2
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_SMDTControlModeType(stream, &SignedMeteringDataType->Dynamic_SMDTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedMeteringDataType->Dynamic_SMDTControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SMDTControlMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Scheduled_SMDTControlMode, Scheduled_SMDTControlModeType (Scheduled_SMDTControlModeType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_SMDTControlModeType(stream, &SignedMeteringDataType->Scheduled_SMDTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedMeteringDataType->Scheduled_SMDTControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SMDTControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}OEMProvisioningCertificateChain; type={urn:iso:std:iso:15118:-20:CommonMessages}SignedCertificateChainType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (1, 1); Certificate, certificateType (1, 1); SubCertificates, SubCertificatesType (0, 1);
static int decode_iso20_SignedCertificateChainType(exi_bitstream_t* stream, struct iso20_SignedCertificateChainType* SignedCertificateChainType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 212;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignedCertificateChainType(SignedCertificateChainType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 212:
            // Grammar: ID=212; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=213
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedCertificateChainType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedCertificateChainType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedCertificateChainType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedCertificateChainType->Id.charactersLen, SignedCertificateChainType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignedCertificateChainType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignedCertificateChainType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignedCertificateChainType->Id.characters[i]))
                                {
                                    SignedCertificateChainType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignedCertificateChainType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 213;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 213:
            // Grammar: ID=213; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=214
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignedCertificateChainType->Certificate.bytesLen, &SignedCertificateChainType->Certificate.bytes[0], iso20_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignedCertificateChainType->Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignedCertificateChainType->Certificate.bytesLen;) {
                            uint32_t octet_a = i < SignedCertificateChainType->Certificate.bytesLen ? (unsigned char) SignedCertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < SignedCertificateChainType->Certificate.bytesLen ? (unsigned char) SignedCertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < SignedCertificateChainType->Certificate.bytesLen ? (unsigned char) SignedCertificateChainType->Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignedCertificateChainType->Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 214;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 214:
            // Grammar: ID=214; read/write bits=2; START (SubCertificates), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SubCertificates, SubCertificatesType (SubCertificatesType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    // decode: element
                    error = decode_iso20_SubCertificatesType(stream, &SignedCertificateChainType->SubCertificates, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        SignedCertificateChainType->SubCertificates_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EIM_AReqAuthorizationMode; type={urn:iso:std:iso:15118:-20:CommonMessages}EIM_AReqAuthorizationModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_EIM_AReqAuthorizationModeType(exi_bitstream_t* stream, struct iso20_EIM_AReqAuthorizationModeType* EIM_AReqAuthorizationModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)EIM_AReqAuthorizationModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SelectedVASList; type={urn:iso:std:iso:15118:-20:CommonMessages}SelectedServiceListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: SelectedService, SelectedServiceType (1, 16);
static int decode_iso20_SelectedServiceListType(exi_bitstream_t* stream, struct iso20_SelectedServiceListType* SelectedServiceListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 215;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SelectedServiceListType(SelectedServiceListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 215:
            // Grammar: ID=215; read/write bits=1; START (SelectedService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedService, SelectedServiceType (SelectedServiceType)); next=216
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso20_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso20_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_SelectedServiceType_16_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 216;

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 216:
            // Grammar: ID=216; read/write bits=2; LOOP (SelectedService), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (SelectedService, SelectedServiceType (SelectedServiceType)); next=216
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService");
                    // decode: element array
                    if (SelectedServiceListType->SelectedService.arrayLen < iso20_SelectedServiceType_16_ARRAY_SIZE)
                    {

                        error = decode_iso20_SelectedServiceType(stream, &SelectedServiceListType->SelectedService.array[SelectedServiceListType->SelectedService.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_SelectedServiceType_16_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (SelectedServiceListType->SelectedService.arrayLen < 16)
                    {
                        grammar_id = 216;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedService>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEReqControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEReqControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: DepartureTime, unsignedInt (1, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); EVTargetEnergyRequest, RationalNumberType (1, 1); EVMaximumEnergyRequest, RationalNumberType (1, 1); EVMinimumEnergyRequest, RationalNumberType (1, 1); EVMaximumV2XEnergyRequest, RationalNumberType (0, 1); EVMinimumV2XEnergyRequest, RationalNumberType (0, 1);
static int decode_iso20_Dynamic_SEReqControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SEReqControlModeType* Dynamic_SEReqControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 217;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Dynamic_SEReqControlModeType(Dynamic_SEReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 217:
            // Grammar: ID=217; read/write bits=1; START (DepartureTime)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=218
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Dynamic_SEReqControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", Dynamic_SEReqControlModeType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 218;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 218:
            // Grammar: ID=218; read/write bits=2; START (MinimumSOC), START (TargetSOC), START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MinimumSOC, percentValueType (byte)); next=219
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEReqControlModeType->MinimumSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEReqControlModeType->MinimumSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEReqControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 219;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TargetSOC, percentValueType (byte)); next=220
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEReqControlModeType->TargetSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEReqControlModeType->TargetSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEReqControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 220;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=221
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVTargetEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 221;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 219:
            // Grammar: ID=219; read/write bits=2; START (TargetSOC), START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TargetSOC, percentValueType (byte)); next=220
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEReqControlModeType->TargetSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEReqControlModeType->TargetSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEReqControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 220;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=221
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVTargetEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 221;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 220:
            // Grammar: ID=220; read/write bits=1; START (EVTargetEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=221
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVTargetEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 221;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 221:
            // Grammar: ID=221; read/write bits=1; START (EVMaximumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=222
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVMaximumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 222;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 222:
            // Grammar: ID=222; read/write bits=1; START (EVMinimumEnergyRequest)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=223
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVMinimumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 223;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 223:
            // Grammar: ID=223; read/write bits=2; START (EVMaximumV2XEnergyRequest), START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=224
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumV2XEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumV2XEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVMaximumV2XEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEReqControlModeType->EVMaximumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 224;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumV2XEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVMinimumV2XEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 224:
            // Grammar: ID=224; read/write bits=2; START (EVMinimumV2XEnergyRequest), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMinimumV2XEnergyRequest, RationalNumberType (RationalNumberType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Dynamic_SEReqControlModeType->EVMinimumV2XEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEReqControlModeType->EVMinimumV2XEnergyRequest_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumV2XEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVSEStatus; type={urn:iso:std:iso:15118:-20:CommonTypes}EVSEStatusType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: NotificationMaxDelay, unsignedShort (1, 1); EVSENotification, evseNotificationType (1, 1);
static int decode_iso20_EVSEStatusType(exi_bitstream_t* stream, struct iso20_EVSEStatusType* EVSEStatusType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 225;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVSEStatusType(EVSEStatusType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 225:
            // Grammar: ID=225; read/write bits=1; START (NotificationMaxDelay)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (NotificationMaxDelay, unsignedShort (unsignedInt)); next=226
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}NotificationMaxDelay");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}NotificationMaxDelay");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &EVSEStatusType->NotificationMaxDelay);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", EVSEStatusType->NotificationMaxDelay);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 226;
                    }

                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}NotificationMaxDelay>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 226:
            // Grammar: ID=226; read/write bits=1; START (EVSENotification)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSENotification, evseNotificationType (string)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}EVSENotification");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}EVSENotification");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 3, &value);
                            if (error == 0)
                            {
                                EVSEStatusType->EVSENotification = (iso20_evseNotificationType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_evseNotificationType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_evseNotificationType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}EVSENotification>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ListOfRootCertificateIDs; type={urn:iso:std:iso:15118:-20:CommonTypes}ListOfRootCertificateIDsType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: RootCertificateID, X509IssuerSerialType (1, 20);
static int decode_iso20_ListOfRootCertificateIDsType(exi_bitstream_t* stream, struct iso20_ListOfRootCertificateIDsType* ListOfRootCertificateIDsType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 227;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ListOfRootCertificateIDsType(ListOfRootCertificateIDsType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 227:
            // Grammar: ID=227; read/write bits=1; START (RootCertificateID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=228
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso20_X509IssuerSerialType_20_ARRAY_SIZE)
                    {

                        error = decode_iso20_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_X509IssuerSerialType_20_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 228;

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 228:
            // Grammar: ID=228; read/write bits=2; LOOP (RootCertificateID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (RootCertificateID, X509IssuerSerialType (X509IssuerSerialType)); next=228
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID");
                    // decode: element array
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < iso20_X509IssuerSerialType_20_ARRAY_SIZE)
                    {

                        error = decode_iso20_X509IssuerSerialType(stream, &ListOfRootCertificateIDsType->RootCertificateID.array[ListOfRootCertificateIDsType->RootCertificateID.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_X509IssuerSerialType_20_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ListOfRootCertificateIDsType->RootCertificateID.arrayLen < 20)
                    {
                        grammar_id = 228;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}RootCertificateID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PnC_AReqAuthorizationMode; type={urn:iso:std:iso:15118:-20:CommonMessages}PnC_AReqAuthorizationModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (1, 1); GenChallenge, genChallengeType (1, 1); ContractCertificateChain, ContractCertificateChainType (1, 1);
static int decode_iso20_PnC_AReqAuthorizationModeType(exi_bitstream_t* stream, struct iso20_PnC_AReqAuthorizationModeType* PnC_AReqAuthorizationModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 229;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PnC_AReqAuthorizationModeType(PnC_AReqAuthorizationModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 229:
            // Grammar: ID=229; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=230
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &PnC_AReqAuthorizationModeType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (PnC_AReqAuthorizationModeType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            PnC_AReqAuthorizationModeType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, PnC_AReqAuthorizationModeType->Id.charactersLen, PnC_AReqAuthorizationModeType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + PnC_AReqAuthorizationModeType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < PnC_AReqAuthorizationModeType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(PnC_AReqAuthorizationModeType->Id.characters[i]))
                                {
                                    PnC_AReqAuthorizationModeType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, PnC_AReqAuthorizationModeType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 230;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 230:
            // Grammar: ID=230; read/write bits=1; START (GenChallenge)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (GenChallenge, genChallengeType (base64Binary)); next=231
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PnC_AReqAuthorizationModeType->GenChallenge.bytesLen, &PnC_AReqAuthorizationModeType->GenChallenge.bytes[0], iso20_genChallengeType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PnC_AReqAuthorizationModeType->GenChallenge.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PnC_AReqAuthorizationModeType->GenChallenge.bytesLen;) {
                            uint32_t octet_a = i < PnC_AReqAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_AReqAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_b = i < PnC_AReqAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_AReqAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_c = i < PnC_AReqAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_AReqAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PnC_AReqAuthorizationModeType->GenChallenge.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 231;
                    }




                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 231:
            // Grammar: ID=231; read/write bits=1; START (ContractCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractCertificateChain, ContractCertificateChainType (ContractCertificateChainType)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain");
                    // decode: element
                    error = decode_iso20_ContractCertificateChainType(stream, &PnC_AReqAuthorizationModeType->ContractCertificateChain, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EnergyTransferServiceList; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Service, ServiceType (1, 8);
static int decode_iso20_ServiceListType(exi_bitstream_t* stream, struct iso20_ServiceListType* ServiceListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 232;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceListType(ServiceListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 232:
            // Grammar: ID=232; read/write bits=1; START (Service)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Service, ServiceType (ServiceType)); next=233
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Service");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso20_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ServiceType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 233;

                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Service>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 233:
            // Grammar: ID=233; read/write bits=2; LOOP (Service), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Service, ServiceType (ServiceType)); next=233
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Service");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Service");
                    // decode: element array
                    if (ServiceListType->Service.arrayLen < iso20_ServiceType_8_ARRAY_SIZE)
                    {

                        error = decode_iso20_ServiceType(stream, &ServiceListType->Service.array[ServiceListType->Service.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ServiceType_8_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ServiceListType->Service.arrayLen < 8)
                    {
                        grammar_id = 233;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Service>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceParameterList; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceParameterListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ParameterSet, ParameterSetType (1, 21) (original max 32);
static int decode_iso20_ServiceParameterListType(exi_bitstream_t* stream, struct iso20_ServiceParameterListType* ServiceParameterListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 234;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceParameterListType(ServiceParameterListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 234:
            // Grammar: ID=234; read/write bits=1; START (ParameterSet)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParameterSet, ParameterSetType (ParameterSetType)); next=235
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso20_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso20_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ParameterSetType_21_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 235;

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 235:
            // Grammar: ID=235; read/write bits=2; LOOP (ParameterSet), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (ParameterSet, ParameterSetType (ParameterSetType)); next=235
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet");
                    // decode: element array
                    if (ServiceParameterListType->ParameterSet.arrayLen < iso20_ParameterSetType_21_ARRAY_SIZE)
                    {

                        error = decode_iso20_ParameterSetType(stream, &ServiceParameterListType->ParameterSet.array[ServiceParameterListType->ParameterSet.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ParameterSetType_21_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (ServiceParameterListType->ParameterSet.arrayLen < 32)
                    {
                        grammar_id = 235;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParameterSet>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEReqControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEReqControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: DepartureTime, unsignedInt (0, 1); EVTargetEnergyRequest, RationalNumberType (0, 1); EVMaximumEnergyRequest, RationalNumberType (0, 1); EVMinimumEnergyRequest, RationalNumberType (0, 1); EVEnergyOffer, EVEnergyOfferType (0, 1);
static int decode_iso20_Scheduled_SEReqControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SEReqControlModeType* Scheduled_SEReqControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 236;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Scheduled_SEReqControlModeType(Scheduled_SEReqControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 236:
            // Grammar: ID=236; read/write bits=3; START (DepartureTime), START (EVTargetEnergyRequest), START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVEnergyOffer), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=237
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Scheduled_SEReqControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", Scheduled_SEReqControlModeType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        Scheduled_SEReqControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 237;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=238
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVTargetEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVTargetEnergyRequest_isUsed = 1u;
                        grammar_id = 238;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=239
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMaximumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 239;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=240
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMinimumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 240;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (EVEnergyOffer, EVEnergyOfferType (EVEnergyOfferType)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    // decode: element
                    error = decode_iso20_EVEnergyOfferType(stream, &Scheduled_SEReqControlModeType->EVEnergyOffer, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVEnergyOffer_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer>");
                    }
                    break;
                case 5:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 237:
            // Grammar: ID=237; read/write bits=3; START (EVTargetEnergyRequest), START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVEnergyOffer), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTargetEnergyRequest, RationalNumberType (RationalNumberType)); next=238
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVTargetEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVTargetEnergyRequest_isUsed = 1u;
                        grammar_id = 238;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTargetEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=239
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMaximumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 239;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=240
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMinimumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 240;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (EVEnergyOffer, EVEnergyOfferType (EVEnergyOfferType)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    // decode: element
                    error = decode_iso20_EVEnergyOfferType(stream, &Scheduled_SEReqControlModeType->EVEnergyOffer, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVEnergyOffer_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 238:
            // Grammar: ID=238; read/write bits=3; START (EVMaximumEnergyRequest), START (EVMinimumEnergyRequest), START (EVEnergyOffer), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMaximumEnergyRequest, RationalNumberType (RationalNumberType)); next=239
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMaximumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMaximumEnergyRequest_isUsed = 1u;
                        grammar_id = 239;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMaximumEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=240
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMinimumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 240;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (EVEnergyOffer, EVEnergyOfferType (EVEnergyOfferType)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    // decode: element
                    error = decode_iso20_EVEnergyOfferType(stream, &Scheduled_SEReqControlModeType->EVEnergyOffer, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVEnergyOffer_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 239:
            // Grammar: ID=239; read/write bits=2; START (EVMinimumEnergyRequest), START (EVEnergyOffer), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVMinimumEnergyRequest, RationalNumberType (RationalNumberType)); next=240
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest");
                    // decode: element
                    error = decode_iso20_RationalNumberType(stream, &Scheduled_SEReqControlModeType->EVMinimumEnergyRequest, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVMinimumEnergyRequest_isUsed = 1u;
                        grammar_id = 240;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVMinimumEnergyRequest>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVEnergyOffer, EVEnergyOfferType (EVEnergyOfferType)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    // decode: element
                    error = decode_iso20_EVEnergyOfferType(stream, &Scheduled_SEReqControlModeType->EVEnergyOffer, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVEnergyOffer_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 240:
            // Grammar: ID=240; read/write bits=2; START (EVEnergyOffer), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVEnergyOffer, EVEnergyOfferType (EVEnergyOfferType)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer");
                    // decode: element
                    error = decode_iso20_EVEnergyOfferType(stream, &Scheduled_SEReqControlModeType->EVEnergyOffer, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Scheduled_SEReqControlModeType->EVEnergyOffer_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVEnergyOffer>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfile; type={urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: TimeAnchor, unsignedLong (1, 1); Dynamic_EVPPTControlMode, Dynamic_EVPPTControlModeType (0, 1); Scheduled_EVPPTControlMode, Scheduled_EVPPTControlModeType (0, 1); EVPowerProfileEntries, EVPowerProfileEntryListType (1, 1);
static int decode_iso20_EVPowerProfileType(exi_bitstream_t* stream, struct iso20_EVPowerProfileType* EVPowerProfileType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 241;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EVPowerProfileType(EVPowerProfileType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 241:
            // Grammar: ID=241; read/write bits=1; START (TimeAnchor)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TimeAnchor, unsignedLong (nonNegativeInteger)); next=242
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &EVPowerProfileType->TimeAnchor);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", EVPowerProfileType->TimeAnchor);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 242;
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TimeAnchor>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 242:
            // Grammar: ID=242; read/write bits=2; START (Dynamic_EVPPTControlMode), START (Scheduled_EVPPTControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Dynamic_EVPPTControlMode, Dynamic_EVPPTControlModeType (Dynamic_EVPPTControlModeType)); next=243
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_EVPPTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_EVPPTControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_EVPPTControlModeType(stream, &EVPowerProfileType->Dynamic_EVPPTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        EVPowerProfileType->Dynamic_EVPPTControlMode_isUsed = 1u;
                        grammar_id = 243;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_EVPPTControlMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Scheduled_EVPPTControlMode, Scheduled_EVPPTControlModeType (Scheduled_EVPPTControlModeType)); next=243
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_EVPPTControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_EVPPTControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_EVPPTControlModeType(stream, &EVPowerProfileType->Scheduled_EVPPTControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        EVPowerProfileType->Scheduled_EVPPTControlMode_isUsed = 1u;
                        grammar_id = 243;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_EVPPTControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 243:
            // Grammar: ID=243; read/write bits=1; START (EVPowerProfileEntries)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerProfileEntries, EVPowerProfileEntryListType (EVPowerProfileEntryListType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntries");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntries");
                    // decode: element
                    error = decode_iso20_EVPowerProfileEntryListType(stream, &EVPowerProfileType->EVPowerProfileEntries, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfileEntries>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}CPSCertificateChain; type={urn:iso:std:iso:15118:-20:CommonMessages}CertificateChainType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Certificate, certificateType (1, 1); SubCertificates, SubCertificatesType (0, 1);
static int decode_iso20_CertificateChainType(exi_bitstream_t* stream, struct iso20_CertificateChainType* CertificateChainType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 244;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_CertificateChainType(CertificateChainType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 244:
            // Grammar: ID=244; read/write bits=1; START (Certificate)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Certificate, certificateType (base64Binary)); next=245
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Certificate");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &CertificateChainType->Certificate.bytesLen, &CertificateChainType->Certificate.bytes[0], iso20_certificateType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((CertificateChainType->Certificate.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < CertificateChainType->Certificate.bytesLen;) {
                            uint32_t octet_a = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_b = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            uint32_t octet_c = i < CertificateChainType->Certificate.bytesLen ? (unsigned char) CertificateChainType->Certificate.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[CertificateChainType->Certificate.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 245;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Certificate>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 245:
            // Grammar: ID=245; read/write bits=2; START (SubCertificates), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SubCertificates, SubCertificatesType (SubCertificatesType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates");
                    // decode: element
                    error = decode_iso20_SubCertificatesType(stream, &CertificateChainType->SubCertificates, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        CertificateChainType->SubCertificates_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SubCertificates>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}EIM_ASResAuthorizationMode; type={urn:iso:std:iso:15118:-20:CommonMessages}EIM_ASResAuthorizationModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_EIM_ASResAuthorizationModeType(exi_bitstream_t* stream, struct iso20_EIM_ASResAuthorizationModeType* EIM_ASResAuthorizationModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)EIM_ASResAuthorizationModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: DepartureTime, unsignedInt (0, 1); MinimumSOC, percentValueType (0, 1); TargetSOC, percentValueType (0, 1); AbsolutePriceSchedule, AbsolutePriceScheduleType (0, 1); PriceLevelSchedule, PriceLevelScheduleType (0, 1);
static int decode_iso20_Dynamic_SEResControlModeType(exi_bitstream_t* stream, struct iso20_Dynamic_SEResControlModeType* Dynamic_SEResControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 246;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Dynamic_SEResControlModeType(Dynamic_SEResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 246:
            // Grammar: ID=246; read/write bits=3; START (DepartureTime), START (MinimumSOC), START (TargetSOC), START (AbsolutePriceSchedule), START (PriceLevelSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DepartureTime, unsignedInt (unsignedLong)); next=247
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime");
                    // decode: unsigned int
                    error = decode_exi_type_uint32(stream, &Dynamic_SEResControlModeType->DepartureTime);
                    if (error == 0)
                    {
                        char append[11]; // max length: 10 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 11 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", Dynamic_SEResControlModeType->DepartureTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        Dynamic_SEResControlModeType->DepartureTime_isUsed = 1u;
                        grammar_id = 247;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DepartureTime>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (MinimumSOC, percentValueType (byte)); next=248
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEResControlModeType->MinimumSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEResControlModeType->MinimumSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 248;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TargetSOC, percentValueType (byte)); next=249
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEResControlModeType->TargetSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEResControlModeType->TargetSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 249;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (AbsolutePriceSchedule, AbsolutePriceScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_AbsolutePriceScheduleType(stream, &Dynamic_SEResControlModeType->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->AbsolutePriceSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule>");
                    }
                    break;
                case 4:
                    {
                    // Event: START (PriceLevelSchedule, PriceLevelScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleType(stream, &Dynamic_SEResControlModeType->PriceLevelSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->PriceLevelSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule>");
                    }
                    break;
                case 5:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 247:
            // Grammar: ID=247; read/write bits=3; START (MinimumSOC), START (TargetSOC), START (AbsolutePriceSchedule), START (PriceLevelSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MinimumSOC, percentValueType (byte)); next=248
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEResControlModeType->MinimumSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEResControlModeType->MinimumSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEResControlModeType->MinimumSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 248;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MinimumSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TargetSOC, percentValueType (byte)); next=249
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEResControlModeType->TargetSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEResControlModeType->TargetSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 249;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (AbsolutePriceSchedule, AbsolutePriceScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_AbsolutePriceScheduleType(stream, &Dynamic_SEResControlModeType->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->AbsolutePriceSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule>");
                    }
                    break;
                case 3:
                    {
                    // Event: START (PriceLevelSchedule, PriceLevelScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleType(stream, &Dynamic_SEResControlModeType->PriceLevelSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->PriceLevelSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule>");
                    }
                    break;
                case 4:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 248:
            // Grammar: ID=248; read/write bits=3; START (TargetSOC), START (AbsolutePriceSchedule), START (PriceLevelSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TargetSOC, percentValueType (byte)); next=249
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 7, &value);
                            if (error == 0)
                            {
                                Dynamic_SEResControlModeType->TargetSOC = (int8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", Dynamic_SEResControlModeType->TargetSOC);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                                Dynamic_SEResControlModeType->TargetSOC_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 249;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetSOC>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (AbsolutePriceSchedule, AbsolutePriceScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_AbsolutePriceScheduleType(stream, &Dynamic_SEResControlModeType->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->AbsolutePriceSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (PriceLevelSchedule, PriceLevelScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleType(stream, &Dynamic_SEResControlModeType->PriceLevelSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->PriceLevelSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 249:
            // Grammar: ID=249; read/write bits=2; START (AbsolutePriceSchedule), START (PriceLevelSchedule), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AbsolutePriceSchedule, AbsolutePriceScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule");
                    // decode: element
                    error = decode_iso20_AbsolutePriceScheduleType(stream, &Dynamic_SEResControlModeType->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->AbsolutePriceSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AbsolutePriceSchedule>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PriceLevelSchedule, PriceLevelScheduleType (PriceScheduleType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule");
                    // decode: element
                    error = decode_iso20_PriceLevelScheduleType(stream, &Dynamic_SEResControlModeType->PriceLevelSchedule, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        Dynamic_SEResControlModeType->PriceLevelSchedule_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PriceLevelSchedule>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PrioritizedEMAIDs; type={urn:iso:std:iso:15118:-20:CommonMessages}EMAIDListType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: EMAID, identifierType (1, 8);
static int decode_iso20_EMAIDListType(exi_bitstream_t* stream, struct iso20_EMAIDListType* EMAIDListType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 250;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_EMAIDListType(EMAIDListType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 250:
            // Grammar: ID=250; read/write bits=1; START (EMAID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EMAID, identifierType (string)); next=251
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EMAID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EMAID");
                    // decode: string (len, characters) (Array)
                    if (EMAIDListType->EMAID.arrayLen < iso20_identifierType_8_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                error = exi_basetypes_decoder_uint_16(stream, &EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen);
                                if (error == 0)
                                {
                                    if (EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen >= 2)
                                    {
                                        // string tables and table partitions are not supported, so the length has to be decremented by 2
                                        EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen -= 2;
                                        error = exi_basetypes_decoder_characters(stream, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters, iso20_EMAID_CHARACTER_SIZE);
                                        if (error == 0)
                                        {
                                            EMAIDListType->EMAID.arrayLen++;
                                        }
                                        strcat(xmlOut, ">");
                                        if(strlen(xmlOut) + EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                        for(int i = 0; i < EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen; i++) { // check for unprintable characters
                                            if(!isprint(EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters[i]))
                                            {
                                                EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters[i]   = '?';
                                            }
                                        }
                                        strcat(xmlOut, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters);
                                    }
                                    else
                                    {
                                        // the string seems to be in the table, but this is not supported
                                        error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                    }
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 251;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EMAID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 251:
            // Grammar: ID=251; read/write bits=2; LOOP (EMAID), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (EMAID, identifierType (string)); next=251
                    if(strlen(xmlOut) + 47 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EMAID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EMAID");
                    // decode: string (len, characters) (Array)
                    if (EMAIDListType->EMAID.arrayLen < iso20_identifierType_8_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                error = exi_basetypes_decoder_uint_16(stream, &EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen);
                                if (error == 0)
                                {
                                    if (EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen >= 2)
                                    {
                                        // string tables and table partitions are not supported, so the length has to be decremented by 2
                                        EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen -= 2;
                                        error = exi_basetypes_decoder_characters(stream, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters, iso20_EMAID_CHARACTER_SIZE);
                                        if (error == 0)
                                        {
                                            EMAIDListType->EMAID.arrayLen++;
                                        }
                                        strcat(xmlOut, ">");
                                        if(strlen(xmlOut) + EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                        for(int i = 0; i < EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].charactersLen; i++) { // check for unprintable characters
                                            if(!isprint(EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters[i]))
                                            {
                                                EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters[i]   = '?';
                                            }
                                        }
                                        strcat(xmlOut, EMAIDListType->EMAID.array[EMAIDListType->EMAID.arrayLen].characters);
                                    }
                                    else
                                    {
                                        // the string seems to be in the table, but this is not supported
                                        error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                    }
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 251;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EMAID>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData; type={urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationDataType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (1, 1); ContractCertificateChain, ContractCertificateChainType (1, 1); ECDHCurve, ecdhCurveType (1, 1); DHPublicKey, dhPublicKeyType (1, 1); SECP521_EncryptedPrivateKey, secp521_EncryptedPrivateKeyType (0, 1); X448_EncryptedPrivateKey, x448_EncryptedPrivateKeyType (0, 1); TPM_EncryptedPrivateKey, tpm_EncryptedPrivateKeyType (0, 1);
static int decode_iso20_SignedInstallationDataType(exi_bitstream_t* stream, struct iso20_SignedInstallationDataType* SignedInstallationDataType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 252;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignedInstallationDataType(SignedInstallationDataType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 252:
            // Grammar: ID=252; read/write bits=1; START (Id)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=253
                    if(strlen(xmlOut) + 44 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " {urn:iso:std:iso:15118:-20:CommonMessages}Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignedInstallationDataType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignedInstallationDataType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignedInstallationDataType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignedInstallationDataType->Id.charactersLen, SignedInstallationDataType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignedInstallationDataType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignedInstallationDataType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignedInstallationDataType->Id.characters[i]))
                                {
                                    SignedInstallationDataType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignedInstallationDataType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    grammar_id = 253;

                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 253:
            // Grammar: ID=253; read/write bits=1; START (ContractCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ContractCertificateChain, ContractCertificateChainType (ContractCertificateChainType)); next=254
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain");
                    // decode: element
                    error = decode_iso20_ContractCertificateChainType(stream, &SignedInstallationDataType->ContractCertificateChain, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 254;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ContractCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 254:
            // Grammar: ID=254; read/write bits=1; START (ECDHCurve)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ECDHCurve, ecdhCurveType (string)); next=255
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ECDHCurve");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ECDHCurve");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                SignedInstallationDataType->ECDHCurve = (iso20_ecdhCurveType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_ecdhCurveType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_ecdhCurveType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 255;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ECDHCurve>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 255:
            // Grammar: ID=255; read/write bits=1; START (DHPublicKey)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DHPublicKey, dhPublicKeyType (base64Binary)); next=256
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DHPublicKey");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DHPublicKey");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignedInstallationDataType->DHPublicKey.bytesLen, &SignedInstallationDataType->DHPublicKey.bytes[0], iso20_dhPublicKeyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignedInstallationDataType->DHPublicKey.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignedInstallationDataType->DHPublicKey.bytesLen;) {
                            uint32_t octet_a = i < SignedInstallationDataType->DHPublicKey.bytesLen ? (unsigned char) SignedInstallationDataType->DHPublicKey.bytes[i++] : 0;
                            uint32_t octet_b = i < SignedInstallationDataType->DHPublicKey.bytesLen ? (unsigned char) SignedInstallationDataType->DHPublicKey.bytes[i++] : 0;
                            uint32_t octet_c = i < SignedInstallationDataType->DHPublicKey.bytesLen ? (unsigned char) SignedInstallationDataType->DHPublicKey.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignedInstallationDataType->DHPublicKey.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 256;
                    }




                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DHPublicKey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 256:
            // Grammar: ID=256; read/write bits=2; START (SECP521_EncryptedPrivateKey), START (X448_EncryptedPrivateKey), START (TPM_EncryptedPrivateKey)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SECP521_EncryptedPrivateKey, secp521_EncryptedPrivateKeyType (base64Binary)); next=2
                    if(strlen(xmlOut) + 69 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SECP521_EncryptedPrivateKey");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SECP521_EncryptedPrivateKey");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen, &SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytes[0], iso20_secp521_EncryptedPrivateKeyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen;) {
                            uint32_t octet_a = i < SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_b = i < SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_c = i < SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignedInstallationDataType->SECP521_EncryptedPrivateKey.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignedInstallationDataType->SECP521_EncryptedPrivateKey_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 69 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SECP521_EncryptedPrivateKey>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (X448_EncryptedPrivateKey, x448_EncryptedPrivateKeyType (base64Binary)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}X448_EncryptedPrivateKey");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}X448_EncryptedPrivateKey");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen, &SignedInstallationDataType->X448_EncryptedPrivateKey.bytes[0], iso20_x448_EncryptedPrivateKeyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen;) {
                            uint32_t octet_a = i < SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->X448_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_b = i < SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->X448_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_c = i < SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->X448_EncryptedPrivateKey.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignedInstallationDataType->X448_EncryptedPrivateKey.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignedInstallationDataType->X448_EncryptedPrivateKey_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}X448_EncryptedPrivateKey>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TPM_EncryptedPrivateKey, tpm_EncryptedPrivateKeyType (base64Binary)); next=2
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TPM_EncryptedPrivateKey");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TPM_EncryptedPrivateKey");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen, &SignedInstallationDataType->TPM_EncryptedPrivateKey.bytes[0], iso20_tpm_EncryptedPrivateKeyType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen;) {
                            uint32_t octet_a = i < SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->TPM_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_b = i < SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->TPM_EncryptedPrivateKey.bytes[i++] : 0;
                            uint32_t octet_c = i < SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen ? (unsigned char) SignedInstallationDataType->TPM_EncryptedPrivateKey.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[SignedInstallationDataType->TPM_EncryptedPrivateKey.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        SignedInstallationDataType->TPM_EncryptedPrivateKey_isUsed = 1u;
                        grammar_id = 2;
                    }




                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TPM_EncryptedPrivateKey>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PnC_ASResAuthorizationMode; type={urn:iso:std:iso:15118:-20:CommonMessages}PnC_ASResAuthorizationModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: GenChallenge, genChallengeType (1, 1); SupportedProviders, SupportedProvidersListType (0, 1);
static int decode_iso20_PnC_ASResAuthorizationModeType(exi_bitstream_t* stream, struct iso20_PnC_ASResAuthorizationModeType* PnC_ASResAuthorizationModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 257;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PnC_ASResAuthorizationModeType(PnC_ASResAuthorizationModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 257:
            // Grammar: ID=257; read/write bits=1; START (GenChallenge)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (GenChallenge, genChallengeType (base64Binary)); next=258
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge");
                    // decode exi type: base64Binary
                    error = decode_exi_type_hex_binary(stream, &PnC_ASResAuthorizationModeType->GenChallenge.bytesLen, &PnC_ASResAuthorizationModeType->GenChallenge.bytes[0], iso20_genChallengeType_BYTES_SIZE);
                    if (error == 0)
                    {
                        // Binary to Base64:
                        char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
                        int mod_table[] = {0, 2, 1};
                        size_t output_length = 4 * ((PnC_ASResAuthorizationModeType->GenChallenge.bytesLen + 2) / 3);
                        unsigned char* encoded_data = (unsigned char*)malloc(output_length);
                        for (int i = 0, j = 0; i < PnC_ASResAuthorizationModeType->GenChallenge.bytesLen;) {
                            uint32_t octet_a = i < PnC_ASResAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_ASResAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_b = i < PnC_ASResAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_ASResAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            uint32_t octet_c = i < PnC_ASResAuthorizationModeType->GenChallenge.bytesLen ? (unsigned char) PnC_ASResAuthorizationModeType->GenChallenge.bytes[i++] : 0;
                            
                            uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
                            
                            encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
                            encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
                        }
                        for (int i = 0; i < mod_table[PnC_ASResAuthorizationModeType->GenChallenge.bytesLen % 3]; i++) {
                            encoded_data[output_length - 1 - i] = '=';
                        }
                        if(strlen(xmlOut) + output_length + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; free(encoded_data); break; }
                        strcat(xmlOut, ">");
                        strncat(xmlOut, (char*)encoded_data, output_length);
                        free(encoded_data);
                        grammar_id = 258;
                    }




                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}GenChallenge>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 258:
            // Grammar: ID=258; read/write bits=2; START (SupportedProviders), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SupportedProviders, SupportedProvidersListType (SupportedProvidersListType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SupportedProviders");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SupportedProviders");
                    // decode: element
                    error = decode_iso20_SupportedProvidersListType(stream, &PnC_ASResAuthorizationModeType->SupportedProviders, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PnC_ASResAuthorizationModeType->SupportedProviders_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SupportedProviders>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode; type={urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlModeType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: ScheduleTuple, ScheduleTupleType (1, 3);
static int decode_iso20_Scheduled_SEResControlModeType(exi_bitstream_t* stream, struct iso20_Scheduled_SEResControlModeType* Scheduled_SEResControlModeType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 259;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_Scheduled_SEResControlModeType(Scheduled_SEResControlModeType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 259:
            // Grammar: ID=259; read/write bits=1; START (ScheduleTuple)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ScheduleTuple, ScheduleTupleType (ScheduleTupleType)); next=260
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple");
                    // decode: element array
                    if (Scheduled_SEResControlModeType->ScheduleTuple.arrayLen < iso20_ScheduleTupleType_3_ARRAY_SIZE)
                    {

                        error = decode_iso20_ScheduleTupleType(stream, &Scheduled_SEResControlModeType->ScheduleTuple.array[Scheduled_SEResControlModeType->ScheduleTuple.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ScheduleTupleType_3_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 260;

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 260:
            // Grammar: ID=260; read/write bits=2; LOOP (ScheduleTuple), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (ScheduleTuple, ScheduleTupleType (ScheduleTupleType)); next=260
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple");
                    // decode: element array
                    if (Scheduled_SEResControlModeType->ScheduleTuple.arrayLen < iso20_ScheduleTupleType_3_ARRAY_SIZE)
                    {

                        error = decode_iso20_ScheduleTupleType(stream, &Scheduled_SEResControlModeType->ScheduleTuple.array[Scheduled_SEResControlModeType->ScheduleTuple.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ScheduleTupleType_3_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // LOOP breakout code for schema given maximum, regardless of ARRAY_SIZE definition
                    if (Scheduled_SEResControlModeType->ScheduleTuple.arrayLen < 3)
                    {
                        grammar_id = 260;
                    }
                    else
                    {
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleTuple>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupReq; type={urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVCCID, identifierType (1, 1);
static int decode_iso20_SessionSetupReqType(exi_bitstream_t* stream, struct iso20_SessionSetupReqType* SessionSetupReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 261;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SessionSetupReqType(SessionSetupReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 261:
            // Grammar: ID=261; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=262
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &SessionSetupReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 262;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 262:
            // Grammar: ID=262; read/write bits=1; START (EVCCID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVCCID, identifierType (string)); next=2
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVCCID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVCCID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionSetupReqType->EVCCID.charactersLen);
                            if (error == 0)
                            {
                                if (SessionSetupReqType->EVCCID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionSetupReqType->EVCCID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionSetupReqType->EVCCID.charactersLen, SessionSetupReqType->EVCCID.characters, iso20_EVCCID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + SessionSetupReqType->EVCCID.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < SessionSetupReqType->EVCCID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionSetupReqType->EVCCID.characters[i]))
                                        {
                                            SessionSetupReqType->EVCCID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionSetupReqType->EVCCID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVCCID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupRes; type={urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEID, identifierType (1, 1);
static int decode_iso20_SessionSetupResType(exi_bitstream_t* stream, struct iso20_SessionSetupResType* SessionSetupResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 263;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SessionSetupResType(SessionSetupResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 263:
            // Grammar: ID=263; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=264
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &SessionSetupResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 264;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 264:
            // Grammar: ID=264; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=265
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                SessionSetupResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 265;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 265:
            // Grammar: ID=265; read/write bits=1; START (EVSEID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEID, identifierType (string)); next=2
                    if(strlen(xmlOut) + 48 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEID");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionSetupResType->EVSEID.charactersLen);
                            if (error == 0)
                            {
                                if (SessionSetupResType->EVSEID.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionSetupResType->EVSEID.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionSetupResType->EVSEID.charactersLen, SessionSetupResType->EVSEID.characters, iso20_EVSEID_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + SessionSetupResType->EVSEID.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < SessionSetupResType->EVSEID.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionSetupResType->EVSEID.characters[i]))
                                        {
                                            SessionSetupResType->EVSEID.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionSetupResType->EVSEID.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSEID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupReq; type={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1);
static int decode_iso20_AuthorizationSetupReqType(exi_bitstream_t* stream, struct iso20_AuthorizationSetupReqType* AuthorizationSetupReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 266;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AuthorizationSetupReqType(AuthorizationSetupReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 266:
            // Grammar: ID=266; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=2
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &AuthorizationSetupReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupRes; type={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); AuthorizationServices, authorizationType (1, 2); CertificateInstallationService, boolean (1, 1); EIM_ASResAuthorizationMode, EIM_ASResAuthorizationModeType (0, 1); PnC_ASResAuthorizationMode, PnC_ASResAuthorizationModeType (0, 1);
static int decode_iso20_AuthorizationSetupResType(exi_bitstream_t* stream, struct iso20_AuthorizationSetupResType* AuthorizationSetupResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 267;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AuthorizationSetupResType(AuthorizationSetupResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 267:
            // Grammar: ID=267; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=268
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &AuthorizationSetupResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 268;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 268:
            // Grammar: ID=268; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=269
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                AuthorizationSetupResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 269;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 269:
            // Grammar: ID=269; read/write bits=1; START (AuthorizationServices)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AuthorizationServices, authorizationType (string)); next=270
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices");
                    // decode: enum array
                    if (AuthorizationSetupResType->AuthorizationServices.arrayLen < iso20_authorizationType_2_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                                if (error == 0)
                                {
                                    AuthorizationSetupResType->AuthorizationServices.array[AuthorizationSetupResType->AuthorizationServices.arrayLen] = (iso20_authorizationType)value;
                                    AuthorizationSetupResType->AuthorizationServices.arrayLen++;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_authorizationType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_authorizationType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 270;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 270:
            // Grammar: ID=270; read/write bits=2; START (AuthorizationServices), START (CertificateInstallationService)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (AuthorizationServices, authorizationType (string)); next=271
                    if(strlen(xmlOut) + 63 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices");
                    // decode: enum array
                    if (AuthorizationSetupResType->AuthorizationServices.arrayLen < iso20_authorizationType_2_ARRAY_SIZE)
                    {
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                uint32_t value;
                                error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                                if (error == 0)
                                {
                                    AuthorizationSetupResType->AuthorizationServices.array[AuthorizationSetupResType->AuthorizationServices.arrayLen] = (iso20_authorizationType)value;
                                    AuthorizationSetupResType->AuthorizationServices.arrayLen++;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_authorizationType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_authorizationType_reverse(value));
                                }
                            }
                            else
                            {
                                // second level event is not supported
                                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                            }
                        }
                    }
                    else
                    {
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 271;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationServices>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (CertificateInstallationService, boolean (boolean)); next=272
                    if(strlen(xmlOut) + 72 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AuthorizationSetupResType->CertificateInstallationService = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 272;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 72 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 271:
            // Grammar: ID=271; read/write bits=1; START (CertificateInstallationService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CertificateInstallationService, boolean (boolean)); next=272
                    if(strlen(xmlOut) + 72 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AuthorizationSetupResType->CertificateInstallationService = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 272;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 72 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 272:
            // Grammar: ID=272; read/write bits=2; START (EIM_ASResAuthorizationMode), START (PnC_ASResAuthorizationMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EIM_ASResAuthorizationMode, EIM_ASResAuthorizationModeType (EIM_ASResAuthorizationModeType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EIM_ASResAuthorizationMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EIM_ASResAuthorizationMode");
                    // decode: element
                    error = decode_iso20_EIM_ASResAuthorizationModeType(stream, &AuthorizationSetupResType->EIM_ASResAuthorizationMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AuthorizationSetupResType->EIM_ASResAuthorizationMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EIM_ASResAuthorizationMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PnC_ASResAuthorizationMode, PnC_ASResAuthorizationModeType (PnC_ASResAuthorizationModeType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PnC_ASResAuthorizationMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PnC_ASResAuthorizationMode");
                    // decode: element
                    error = decode_iso20_PnC_ASResAuthorizationModeType(stream, &AuthorizationSetupResType->PnC_ASResAuthorizationMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AuthorizationSetupResType->PnC_ASResAuthorizationMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PnC_ASResAuthorizationMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationReq; type={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); SelectedAuthorizationService, authorizationType (1, 1); EIM_AReqAuthorizationMode, EIM_AReqAuthorizationModeType (0, 1); PnC_AReqAuthorizationMode, PnC_AReqAuthorizationModeType (0, 1);
static int decode_iso20_AuthorizationReqType(exi_bitstream_t* stream, struct iso20_AuthorizationReqType* AuthorizationReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 273;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AuthorizationReqType(AuthorizationReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 273:
            // Grammar: ID=273; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=274
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &AuthorizationReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 274;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 274:
            // Grammar: ID=274; read/write bits=1; START (SelectedAuthorizationService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedAuthorizationService, authorizationType (string)); next=275
                    if(strlen(xmlOut) + 70 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedAuthorizationService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedAuthorizationService");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                AuthorizationReqType->SelectedAuthorizationService = (iso20_authorizationType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_authorizationType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_authorizationType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 275;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 70 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedAuthorizationService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 275:
            // Grammar: ID=275; read/write bits=2; START (EIM_AReqAuthorizationMode), START (PnC_AReqAuthorizationMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EIM_AReqAuthorizationMode, EIM_AReqAuthorizationModeType (EIM_AReqAuthorizationModeType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EIM_AReqAuthorizationMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EIM_AReqAuthorizationMode");
                    // decode: element
                    error = decode_iso20_EIM_AReqAuthorizationModeType(stream, &AuthorizationReqType->EIM_AReqAuthorizationMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AuthorizationReqType->EIM_AReqAuthorizationMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EIM_AReqAuthorizationMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (PnC_AReqAuthorizationMode, PnC_AReqAuthorizationModeType (PnC_AReqAuthorizationModeType)); next=2
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PnC_AReqAuthorizationMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PnC_AReqAuthorizationMode");
                    // decode: element
                    error = decode_iso20_PnC_AReqAuthorizationModeType(stream, &AuthorizationReqType->PnC_AReqAuthorizationMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        AuthorizationReqType->PnC_AReqAuthorizationMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PnC_AReqAuthorizationMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationRes; type={urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1);
static int decode_iso20_AuthorizationResType(exi_bitstream_t* stream, struct iso20_AuthorizationResType* AuthorizationResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 276;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_AuthorizationResType(AuthorizationResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 276:
            // Grammar: ID=276; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=277
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &AuthorizationResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 277;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 277:
            // Grammar: ID=277; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=278
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                AuthorizationResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 278;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 278:
            // Grammar: ID=278; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, processingType (string)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                AuthorizationResType->EVSEProcessing = (iso20_processingType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_processingType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_processingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryReq; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); SupportedServiceIDs, ServiceIDListType (0, 1);
static int decode_iso20_ServiceDiscoveryReqType(exi_bitstream_t* stream, struct iso20_ServiceDiscoveryReqType* ServiceDiscoveryReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 279;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceDiscoveryReqType(ServiceDiscoveryReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 279:
            // Grammar: ID=279; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=280
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceDiscoveryReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 280;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 280:
            // Grammar: ID=280; read/write bits=2; START (SupportedServiceIDs), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SupportedServiceIDs, ServiceIDListType (ServiceIDListType)); next=2
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SupportedServiceIDs");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SupportedServiceIDs");
                    // decode: element
                    error = decode_iso20_ServiceIDListType(stream, &ServiceDiscoveryReqType->SupportedServiceIDs, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ServiceDiscoveryReqType->SupportedServiceIDs_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SupportedServiceIDs>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryRes; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); ServiceRenegotiationSupported, boolean (1, 1); EnergyTransferServiceList, ServiceListType (1, 1); VASList, ServiceListType (0, 1);
static int decode_iso20_ServiceDiscoveryResType(exi_bitstream_t* stream, struct iso20_ServiceDiscoveryResType* ServiceDiscoveryResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 281;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceDiscoveryResType(ServiceDiscoveryResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 281:
            // Grammar: ID=281; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=282
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceDiscoveryResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 282;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 282:
            // Grammar: ID=282; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=283
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                ServiceDiscoveryResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 283;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 283:
            // Grammar: ID=283; read/write bits=1; START (ServiceRenegotiationSupported)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceRenegotiationSupported, boolean (boolean)); next=284
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceRenegotiationSupported");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceRenegotiationSupported");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ServiceDiscoveryResType->ServiceRenegotiationSupported = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 284;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceRenegotiationSupported>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 284:
            // Grammar: ID=284; read/write bits=1; START (EnergyTransferServiceList)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EnergyTransferServiceList, ServiceListType (ServiceListType)); next=285
                    if(strlen(xmlOut) + 67 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyTransferServiceList");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EnergyTransferServiceList");
                    // decode: element
                    error = decode_iso20_ServiceListType(stream, &ServiceDiscoveryResType->EnergyTransferServiceList, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 285;
                    }


                    if(strlen(xmlOut) + 67 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EnergyTransferServiceList>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 285:
            // Grammar: ID=285; read/write bits=2; START (VASList), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (VASList, ServiceListType (ServiceListType)); next=2
                    if(strlen(xmlOut) + 49 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VASList");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}VASList");
                    // decode: element
                    error = decode_iso20_ServiceListType(stream, &ServiceDiscoveryResType->VASList, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ServiceDiscoveryResType->VASList_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 49 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VASList>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailReq; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ServiceID, serviceIDType (1, 1);
static int decode_iso20_ServiceDetailReqType(exi_bitstream_t* stream, struct iso20_ServiceDetailReqType* ServiceDetailReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 286;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceDetailReqType(ServiceDetailReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 286:
            // Grammar: ID=286; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=287
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceDetailReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 287;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 287:
            // Grammar: ID=287; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceDetailReqType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", ServiceDetailReqType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailRes; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); ServiceID, serviceIDType (1, 1); ServiceParameterList, ServiceParameterListType (1, 1);
static int decode_iso20_ServiceDetailResType(exi_bitstream_t* stream, struct iso20_ServiceDetailResType* ServiceDetailResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 288;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceDetailResType(ServiceDetailResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 288:
            // Grammar: ID=288; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=289
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceDetailResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 289;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 289:
            // Grammar: ID=289; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=290
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                ServiceDetailResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 290;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 290:
            // Grammar: ID=290; read/write bits=1; START (ServiceID)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceID, serviceIDType (unsignedShort)); next=291
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID");
                    // decode: unsigned short
                    error = decode_exi_type_uint16(stream, &ServiceDetailResType->ServiceID);
                    if (error == 0)
                    {
                        char append[6]; // max length: 5 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 6 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%u", ServiceDetailResType->ServiceID);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 291;
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceID>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 291:
            // Grammar: ID=291; read/write bits=1; START (ServiceParameterList)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ServiceParameterList, ServiceParameterListType (ServiceParameterListType)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceParameterList");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceParameterList");
                    // decode: element
                    error = decode_iso20_ServiceParameterListType(stream, &ServiceDetailResType->ServiceParameterList, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceParameterList>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionReq; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); SelectedEnergyTransferService, SelectedServiceType (1, 1); SelectedVASList, SelectedServiceListType (0, 1);
static int decode_iso20_ServiceSelectionReqType(exi_bitstream_t* stream, struct iso20_ServiceSelectionReqType* ServiceSelectionReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 292;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceSelectionReqType(ServiceSelectionReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 292:
            // Grammar: ID=292; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=293
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceSelectionReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 293;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 293:
            // Grammar: ID=293; read/write bits=1; START (SelectedEnergyTransferService)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedEnergyTransferService, SelectedServiceType (SelectedServiceType)); next=294
                    if(strlen(xmlOut) + 71 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedEnergyTransferService");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedEnergyTransferService");
                    // decode: element
                    error = decode_iso20_SelectedServiceType(stream, &ServiceSelectionReqType->SelectedEnergyTransferService, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 294;
                    }


                    if(strlen(xmlOut) + 71 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedEnergyTransferService>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 294:
            // Grammar: ID=294; read/write bits=2; START (SelectedVASList), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SelectedVASList, SelectedServiceListType (SelectedServiceListType)); next=2
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedVASList");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SelectedVASList");
                    // decode: element
                    error = decode_iso20_SelectedServiceListType(stream, &ServiceSelectionReqType->SelectedVASList, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ServiceSelectionReqType->SelectedVASList_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SelectedVASList>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionRes; type={urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1);
static int decode_iso20_ServiceSelectionResType(exi_bitstream_t* stream, struct iso20_ServiceSelectionResType* ServiceSelectionResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 295;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ServiceSelectionResType(ServiceSelectionResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 295:
            // Grammar: ID=295; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=296
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ServiceSelectionResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 296;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 296:
            // Grammar: ID=296; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                ServiceSelectionResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeReq; type={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); MaximumSupportingPoints, maxSupportingPointsScheduleTupleType (1, 1); Dynamic_SEReqControlMode, Dynamic_SEReqControlModeType (0, 1); Scheduled_SEReqControlMode, Scheduled_SEReqControlModeType (0, 1);
static int decode_iso20_ScheduleExchangeReqType(exi_bitstream_t* stream, struct iso20_ScheduleExchangeReqType* ScheduleExchangeReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 297;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ScheduleExchangeReqType(ScheduleExchangeReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 297:
            // Grammar: ID=297; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=298
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ScheduleExchangeReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 298;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 298:
            // Grammar: ID=298; read/write bits=1; START (MaximumSupportingPoints)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MaximumSupportingPoints, maxSupportingPointsScheduleTupleType (unsignedShort)); next=299
                    if(strlen(xmlOut) + 65 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumSupportingPoints");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumSupportingPoints");
                    // decode: restricted integer (4096 or fewer values)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 10, &value);
                            if (error == 0)
                            {
                                // type has min_value = 12
                                ScheduleExchangeReqType->MaximumSupportingPoints = (uint16_t)(value + 12);
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", ScheduleExchangeReqType->MaximumSupportingPoints);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 299;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MaximumSupportingPoints>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 299:
            // Grammar: ID=299; read/write bits=2; START (Dynamic_SEReqControlMode), START (Scheduled_SEReqControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Dynamic_SEReqControlMode, Dynamic_SEReqControlModeType (Dynamic_SEReqControlModeType)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEReqControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEReqControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_SEReqControlModeType(stream, &ScheduleExchangeReqType->Dynamic_SEReqControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeReqType->Dynamic_SEReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEReqControlMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Scheduled_SEReqControlMode, Scheduled_SEReqControlModeType (Scheduled_SEReqControlModeType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEReqControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEReqControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_SEReqControlModeType(stream, &ScheduleExchangeReqType->Scheduled_SEReqControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeReqType->Scheduled_SEReqControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEReqControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeRes; type={urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1); GoToPause, boolean (0, 1); Dynamic_SEResControlMode, Dynamic_SEResControlModeType (0, 1); Scheduled_SEResControlMode, Scheduled_SEResControlModeType (0, 1);
static int decode_iso20_ScheduleExchangeResType(exi_bitstream_t* stream, struct iso20_ScheduleExchangeResType* ScheduleExchangeResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 300;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ScheduleExchangeResType(ScheduleExchangeResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 300:
            // Grammar: ID=300; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=301
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &ScheduleExchangeResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 301;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 301:
            // Grammar: ID=301; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=302
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                ScheduleExchangeResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 302;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 302:
            // Grammar: ID=302; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, processingType (string)); next=303
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                ScheduleExchangeResType->EVSEProcessing = (iso20_processingType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_processingType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_processingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 303;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 303:
            // Grammar: ID=303; read/write bits=2; START (GoToPause), START (Dynamic_SEResControlMode), START (Scheduled_SEResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (GoToPause, boolean (boolean)); next=304
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}GoToPause");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}GoToPause");
                    // decode: boolean
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                ScheduleExchangeResType->GoToPause = value;
                                if(strlen(xmlOut) + 8 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, value ? "true" : "false");
                                ScheduleExchangeResType->GoToPause_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 304;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}GoToPause>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Dynamic_SEResControlMode, Dynamic_SEResControlModeType (Dynamic_SEResControlModeType)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_SEResControlModeType(stream, &ScheduleExchangeResType->Dynamic_SEResControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeResType->Dynamic_SEResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (Scheduled_SEResControlMode, Scheduled_SEResControlModeType (Scheduled_SEResControlModeType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_SEResControlModeType(stream, &ScheduleExchangeResType->Scheduled_SEResControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeResType->Scheduled_SEResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 304:
            // Grammar: ID=304; read/write bits=2; START (Dynamic_SEResControlMode), START (Scheduled_SEResControlMode)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Dynamic_SEResControlMode, Dynamic_SEResControlModeType (Dynamic_SEResControlModeType)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode");
                    // decode: element
                    error = decode_iso20_Dynamic_SEResControlModeType(stream, &ScheduleExchangeResType->Dynamic_SEResControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeResType->Dynamic_SEResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Dynamic_SEResControlMode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (Scheduled_SEResControlMode, Scheduled_SEResControlModeType (Scheduled_SEResControlModeType)); next=2
                    if(strlen(xmlOut) + 68 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode");
                    // decode: element
                    error = decode_iso20_Scheduled_SEResControlModeType(stream, &ScheduleExchangeResType->Scheduled_SEResControlMode, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        ScheduleExchangeResType->Scheduled_SEResControlMode_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}Scheduled_SEResControlMode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryReq; type={urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVProcessing, processingType (1, 1); ChargeProgress, chargeProgressType (1, 1); EVPowerProfile, EVPowerProfileType (0, 1); BPT_ChannelSelection, channelSelectionType (0, 1);
static int decode_iso20_PowerDeliveryReqType(exi_bitstream_t* stream, struct iso20_PowerDeliveryReqType* PowerDeliveryReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 305;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PowerDeliveryReqType(PowerDeliveryReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 305:
            // Grammar: ID=305; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=306
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &PowerDeliveryReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 306;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 306:
            // Grammar: ID=306; read/write bits=1; START (EVProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVProcessing, processingType (string)); next=307
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVProcessing");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                PowerDeliveryReqType->EVProcessing = (iso20_processingType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_processingType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_processingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 307;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 307:
            // Grammar: ID=307; read/write bits=1; START (ChargeProgress)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargeProgress, chargeProgressType (string)); next=308
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ChargeProgress");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ChargeProgress");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                PowerDeliveryReqType->ChargeProgress = (iso20_chargeProgressType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_chargeProgressType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_chargeProgressType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 308;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ChargeProgress>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 308:
            // Grammar: ID=308; read/write bits=2; START (EVPowerProfile), START (BPT_ChannelSelection), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVPowerProfile, EVPowerProfileType (EVPowerProfileType)); next=309
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfile");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfile");
                    // decode: element
                    error = decode_iso20_EVPowerProfileType(stream, &PowerDeliveryReqType->EVPowerProfile, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerDeliveryReqType->EVPowerProfile_isUsed = 1u;
                        grammar_id = 309;
                    }


                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVPowerProfile>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (BPT_ChannelSelection, channelSelectionType (string)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                PowerDeliveryReqType->BPT_ChannelSelection = (iso20_channelSelectionType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_channelSelectionType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_channelSelectionType_reverse(value));
                                PowerDeliveryReqType->BPT_ChannelSelection_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 309:
            // Grammar: ID=309; read/write bits=2; START (BPT_ChannelSelection), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (BPT_ChannelSelection, channelSelectionType (string)); next=2
                    if(strlen(xmlOut) + 62 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                PowerDeliveryReqType->BPT_ChannelSelection = (iso20_channelSelectionType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_channelSelectionType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_channelSelectionType_reverse(value));
                                PowerDeliveryReqType->BPT_ChannelSelection_isUsed = 1u;
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 62 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}BPT_ChannelSelection>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryRes; type={urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEStatus, EVSEStatusType (0, 1);
static int decode_iso20_PowerDeliveryResType(exi_bitstream_t* stream, struct iso20_PowerDeliveryResType* PowerDeliveryResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 310;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_PowerDeliveryResType(PowerDeliveryResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 310:
            // Grammar: ID=310; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=311
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &PowerDeliveryResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 311;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 311:
            // Grammar: ID=311; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=312
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                PowerDeliveryResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 312;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 312:
            // Grammar: ID=312; read/write bits=2; START (EVSEStatus), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEStatus, EVSEStatusType (EVSEStatusType)); next=2
                    if(strlen(xmlOut) + 52 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEStatus");
                    // decode: element
                    error = decode_iso20_EVSEStatusType(stream, &PowerDeliveryResType->EVSEStatus, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        PowerDeliveryResType->EVSEStatus_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 52 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSEStatus>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationReq; type={urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); SignedMeteringData, SignedMeteringDataType (1, 1);
static int decode_iso20_MeteringConfirmationReqType(exi_bitstream_t* stream, struct iso20_MeteringConfirmationReqType* MeteringConfirmationReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 313;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_MeteringConfirmationReqType(MeteringConfirmationReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 313:
            // Grammar: ID=313; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=314
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &MeteringConfirmationReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 314;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 314:
            // Grammar: ID=314; read/write bits=1; START (SignedMeteringData)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignedMeteringData, SignedMeteringDataType (SignedMeteringDataType)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData");
                    // decode: element
                    error = decode_iso20_SignedMeteringDataType(stream, &MeteringConfirmationReqType->SignedMeteringData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationRes; type={urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1);
static int decode_iso20_MeteringConfirmationResType(exi_bitstream_t* stream, struct iso20_MeteringConfirmationResType* MeteringConfirmationResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 315;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_MeteringConfirmationResType(MeteringConfirmationResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 315:
            // Grammar: ID=315; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=316
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &MeteringConfirmationResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 316;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 316:
            // Grammar: ID=316; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                MeteringConfirmationResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SessionStopReq; type={urn:iso:std:iso:15118:-20:CommonMessages}SessionStopReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ChargingSession, chargingSessionType (1, 1); EVTerminationCode, nameType (0, 1); EVTerminationExplanation, descriptionType (0, 1);
static int decode_iso20_SessionStopReqType(exi_bitstream_t* stream, struct iso20_SessionStopReqType* SessionStopReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 317;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SessionStopReqType(SessionStopReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 317:
            // Grammar: ID=317; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=318
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &SessionStopReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 318;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 318:
            // Grammar: ID=318; read/write bits=1; START (ChargingSession)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ChargingSession, chargingSessionType (string)); next=319
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSession");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSession");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                SessionStopReqType->ChargingSession = (iso20_chargingSessionType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_chargingSessionType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_chargingSessionType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 319;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ChargingSession>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 319:
            // Grammar: ID=319; read/write bits=2; START (EVTerminationCode), START (EVTerminationExplanation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTerminationCode, nameType (string)); next=320
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationCode");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionStopReqType->EVTerminationCode.charactersLen);
                            if (error == 0)
                            {
                                if (SessionStopReqType->EVTerminationCode.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionStopReqType->EVTerminationCode.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionStopReqType->EVTerminationCode.charactersLen, SessionStopReqType->EVTerminationCode.characters, iso20_EVTerminationCode_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + SessionStopReqType->EVTerminationCode.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < SessionStopReqType->EVTerminationCode.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionStopReqType->EVTerminationCode.characters[i]))
                                        {
                                            SessionStopReqType->EVTerminationCode.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionStopReqType->EVTerminationCode.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                SessionStopReqType->EVTerminationCode_isUsed = 1u;
                                grammar_id = 320;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationCode>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (EVTerminationExplanation, descriptionType (string)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionStopReqType->EVTerminationExplanation.charactersLen);
                            if (error == 0)
                            {
                                if (SessionStopReqType->EVTerminationExplanation.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionStopReqType->EVTerminationExplanation.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionStopReqType->EVTerminationExplanation.charactersLen, SessionStopReqType->EVTerminationExplanation.characters, iso20_EVTerminationExplanation_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + SessionStopReqType->EVTerminationExplanation.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < SessionStopReqType->EVTerminationExplanation.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionStopReqType->EVTerminationExplanation.characters[i]))
                                        {
                                            SessionStopReqType->EVTerminationExplanation.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionStopReqType->EVTerminationExplanation.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                SessionStopReqType->EVTerminationExplanation_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 320:
            // Grammar: ID=320; read/write bits=2; START (EVTerminationExplanation), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVTerminationExplanation, descriptionType (string)); next=2
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation");
                    // decode: string (len, characters)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            error = exi_basetypes_decoder_uint_16(stream, &SessionStopReqType->EVTerminationExplanation.charactersLen);
                            if (error == 0)
                            {
                                if (SessionStopReqType->EVTerminationExplanation.charactersLen >= 2)
                                {
                                    // string tables and table partitions are not supported, so the length has to be decremented by 2
                                    SessionStopReqType->EVTerminationExplanation.charactersLen -= 2;
                                    error = exi_basetypes_decoder_characters(stream, SessionStopReqType->EVTerminationExplanation.charactersLen, SessionStopReqType->EVTerminationExplanation.characters, iso20_EVTerminationExplanation_CHARACTER_SIZE);
                                    strcat(xmlOut, ">");
                                    if(strlen(xmlOut) + SessionStopReqType->EVTerminationExplanation.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                    for(int i = 0; i < SessionStopReqType->EVTerminationExplanation.charactersLen; i++) { // check for unprintable characters
                                        if(!isprint(SessionStopReqType->EVTerminationExplanation.characters[i]))
                                        {
                                            SessionStopReqType->EVTerminationExplanation.characters[i]   = '?';
                                        }
                                    }
                                    strcat(xmlOut, SessionStopReqType->EVTerminationExplanation.characters);
                                }
                                else
                                {
                                    // the string seems to be in the table, but this is not supported
                                    error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                                }
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_characters is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                SessionStopReqType->EVTerminationExplanation_isUsed = 1u;
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVTerminationExplanation>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}SessionStopRes; type={urn:iso:std:iso:15118:-20:CommonMessages}SessionStopResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1);
static int decode_iso20_SessionStopResType(exi_bitstream_t* stream, struct iso20_SessionStopResType* SessionStopResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 321;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SessionStopResType(SessionStopResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 321:
            // Grammar: ID=321; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=322
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &SessionStopResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 322;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 322:
            // Grammar: ID=322; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=2
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                SessionStopResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationReq; type={urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); OEMProvisioningCertificateChain, SignedCertificateChainType (1, 1); ListOfRootCertificateIDs, ListOfRootCertificateIDsType (1, 1); MaximumContractCertificateChains, unsignedByte (1, 1); PrioritizedEMAIDs, EMAIDListType (0, 1);
static int decode_iso20_CertificateInstallationReqType(exi_bitstream_t* stream, struct iso20_CertificateInstallationReqType* CertificateInstallationReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 323;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_CertificateInstallationReqType(CertificateInstallationReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 323:
            // Grammar: ID=323; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=324
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &CertificateInstallationReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 324;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 324:
            // Grammar: ID=324; read/write bits=1; START (OEMProvisioningCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (OEMProvisioningCertificateChain, SignedCertificateChainType (SignedCertificateChainType)); next=325
                    if(strlen(xmlOut) + 73 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}OEMProvisioningCertificateChain");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}OEMProvisioningCertificateChain");
                    // decode: element
                    error = decode_iso20_SignedCertificateChainType(stream, &CertificateInstallationReqType->OEMProvisioningCertificateChain, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 325;
                    }


                    if(strlen(xmlOut) + 73 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}OEMProvisioningCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 325:
            // Grammar: ID=325; read/write bits=1; START (ListOfRootCertificateIDs)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ListOfRootCertificateIDs, ListOfRootCertificateIDsType (ListOfRootCertificateIDsType)); next=326
                    if(strlen(xmlOut) + 66 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ListOfRootCertificateIDs");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ListOfRootCertificateIDs");
                    // decode: element
                    error = decode_iso20_ListOfRootCertificateIDsType(stream, &CertificateInstallationReqType->ListOfRootCertificateIDs, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 326;
                    }


                    if(strlen(xmlOut) + 66 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ListOfRootCertificateIDs>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 326:
            // Grammar: ID=326; read/write bits=1; START (MaximumContractCertificateChains)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (MaximumContractCertificateChains, unsignedByte (unsignedShort)); next=327
                    if(strlen(xmlOut) + 74 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumContractCertificateChains");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}MaximumContractCertificateChains");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                CertificateInstallationReqType->MaximumContractCertificateChains = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", CertificateInstallationReqType->MaximumContractCertificateChains);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 327;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 74 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MaximumContractCertificateChains>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 327:
            // Grammar: ID=327; read/write bits=2; START (PrioritizedEMAIDs), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (PrioritizedEMAIDs, EMAIDListType (EMAIDListType)); next=2
                    if(strlen(xmlOut) + 59 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PrioritizedEMAIDs");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}PrioritizedEMAIDs");
                    // decode: element
                    error = decode_iso20_EMAIDListType(stream, &CertificateInstallationReqType->PrioritizedEMAIDs, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        CertificateInstallationReqType->PrioritizedEMAIDs_isUsed = 1u;
                        grammar_id = 2;
                    }


                    if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PrioritizedEMAIDs>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationRes; type={urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSEProcessing, processingType (1, 1); CPSCertificateChain, CertificateChainType (1, 1); SignedInstallationData, SignedInstallationDataType (1, 1); RemainingContractCertificateChains, unsignedByte (1, 1);
static int decode_iso20_CertificateInstallationResType(exi_bitstream_t* stream, struct iso20_CertificateInstallationResType* CertificateInstallationResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 328;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_CertificateInstallationResType(CertificateInstallationResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 328:
            // Grammar: ID=328; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=329
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &CertificateInstallationResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 329;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 329:
            // Grammar: ID=329; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=330
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                CertificateInstallationResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 330;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 330:
            // Grammar: ID=330; read/write bits=1; START (EVSEProcessing)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSEProcessing, processingType (string)); next=331
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                CertificateInstallationResType->EVSEProcessing = (iso20_processingType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_processingType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_processingType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 331;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSEProcessing>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 331:
            // Grammar: ID=331; read/write bits=1; START (CPSCertificateChain)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CPSCertificateChain, CertificateChainType (CertificateChainType)); next=332
                    if(strlen(xmlOut) + 61 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CPSCertificateChain");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CPSCertificateChain");
                    // decode: element
                    error = decode_iso20_CertificateChainType(stream, &CertificateInstallationResType->CPSCertificateChain, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 332;
                    }


                    if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CPSCertificateChain>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 332:
            // Grammar: ID=332; read/write bits=1; START (SignedInstallationData)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignedInstallationData, SignedInstallationDataType (SignedInstallationDataType)); next=333
                    if(strlen(xmlOut) + 64 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData");
                    // decode: element
                    error = decode_iso20_SignedInstallationDataType(stream, &CertificateInstallationResType->SignedInstallationData, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 333;
                    }


                    if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 333:
            // Grammar: ID=333; read/write bits=1; START (RemainingContractCertificateChains)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (RemainingContractCertificateChains, unsignedByte (unsignedShort)); next=2
                    if(strlen(xmlOut) + 76 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}RemainingContractCertificateChains");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}RemainingContractCertificateChains");
                    // decode: unsigned byte (restricted integer)
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 8, &value);
                            if (error == 0)
                            {
                                CertificateInstallationResType->RemainingContractCertificateChains = (uint8_t)value;
                                if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                char append[7]; // max length: 5 digits (uint8) + 1 sign + 1 zero terminator
                                sprintf(append, "%d", CertificateInstallationResType->RemainingContractCertificateChains);
                                strcat(xmlOut, ">");
                                strcat(xmlOut, append);
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 76 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}RemainingContractCertificateChains>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInReq; type={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVCheckInStatus, evCheckInStatusType (1, 1); ParkingMethod, parkingMethodType (1, 1); VehicleFrame, short (0, 1); DeviceOffset, short (0, 1); VehicleTravel, short (0, 1);
static int decode_iso20_VehicleCheckInReqType(exi_bitstream_t* stream, struct iso20_VehicleCheckInReqType* VehicleCheckInReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 334;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_VehicleCheckInReqType(VehicleCheckInReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 334:
            // Grammar: ID=334; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=335
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &VehicleCheckInReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 335;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 335:
            // Grammar: ID=335; read/write bits=1; START (EVCheckInStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVCheckInStatus, evCheckInStatusType (string)); next=336
                    if(strlen(xmlOut) + 57 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckInStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckInStatus");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                VehicleCheckInReqType->EVCheckInStatus = (iso20_evCheckInStatusType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_evCheckInStatusType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_evCheckInStatusType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 336;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckInStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 336:
            // Grammar: ID=336; read/write bits=1; START (ParkingMethod)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParkingMethod, parkingMethodType (string)); next=337
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingMethod");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingMethod");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                VehicleCheckInReqType->ParkingMethod = (iso20_parkingMethodType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_parkingMethodType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_parkingMethodType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 337;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParkingMethod>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 337:
            // Grammar: ID=337; read/write bits=3; START (VehicleFrame), START (DeviceOffset), START (VehicleTravel), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (VehicleFrame, short (int)); next=338
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleFrame");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleFrame");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->VehicleFrame);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->VehicleFrame);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->VehicleFrame_isUsed = 1u;
                        grammar_id = 338;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleFrame>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DeviceOffset, short (int)); next=339
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->DeviceOffset);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->DeviceOffset);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->DeviceOffset_isUsed = 1u;
                        grammar_id = 339;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (VehicleTravel, short (int)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->VehicleTravel);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->VehicleTravel);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->VehicleTravel_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 338:
            // Grammar: ID=338; read/write bits=2; START (DeviceOffset), START (VehicleTravel), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DeviceOffset, short (int)); next=339
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->DeviceOffset);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->DeviceOffset);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->DeviceOffset_isUsed = 1u;
                        grammar_id = 339;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DeviceOffset>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (VehicleTravel, short (int)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->VehicleTravel);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->VehicleTravel);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->VehicleTravel_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 339:
            // Grammar: ID=339; read/write bits=2; START (VehicleTravel), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (VehicleTravel, short (int)); next=2
                    if(strlen(xmlOut) + 55 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInReqType->VehicleTravel);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInReqType->VehicleTravel);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInReqType->VehicleTravel_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleTravel>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInRes; type={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); ParkingSpace, short (0, 1); DeviceLocation, short (0, 1); TargetDistance, short (0, 1);
static int decode_iso20_VehicleCheckInResType(exi_bitstream_t* stream, struct iso20_VehicleCheckInResType* VehicleCheckInResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 340;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_VehicleCheckInResType(VehicleCheckInResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 340:
            // Grammar: ID=340; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=341
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &VehicleCheckInResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 341;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 341:
            // Grammar: ID=341; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=342
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                VehicleCheckInResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 342;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 342:
            // Grammar: ID=342; read/write bits=3; START (ParkingSpace), START (DeviceLocation), START (TargetDistance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 3, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ParkingSpace, short (int)); next=343
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingSpace");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}ParkingSpace");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->ParkingSpace);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->ParkingSpace);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->ParkingSpace_isUsed = 1u;
                        grammar_id = 343;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ParkingSpace>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (DeviceLocation, short (int)); next=344
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->DeviceLocation);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->DeviceLocation);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->DeviceLocation_isUsed = 1u;
                        grammar_id = 344;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation>");
                    }
                    break;
                case 2:
                    {
                    // Event: START (TargetDistance, short (int)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->TargetDistance);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->TargetDistance);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->TargetDistance_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance>");
                    }
                    break;
                case 3:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 343:
            // Grammar: ID=343; read/write bits=2; START (DeviceLocation), START (TargetDistance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (DeviceLocation, short (int)); next=344
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->DeviceLocation);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->DeviceLocation);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->DeviceLocation_isUsed = 1u;
                        grammar_id = 344;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}DeviceLocation>");
                    }
                    break;
                case 1:
                    {
                    // Event: START (TargetDistance, short (int)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->TargetDistance);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->TargetDistance);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->TargetDistance_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance>");
                    }
                    break;
                case 2:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 344:
            // Grammar: ID=344; read/write bits=2; START (TargetDistance), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (TargetDistance, short (int)); next=2
                    if(strlen(xmlOut) + 56 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance");
                    // decode: short
                    error = decode_exi_type_integer16(stream, &VehicleCheckInResType->TargetDistance);
                    if (error == 0)
                    {
                        char append[7]; // max length: 5 digits + 1 sign + 1 zero terminator
                        if(strlen(xmlOut) + 7 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%d", VehicleCheckInResType->TargetDistance);
// TODO the short value 'Value' of physical value type is an attribute according to cbexigen. Uncomment me (in jinja) as soon as it is fixed
//
                        strcat(xmlOut, ">");
//
                        strcat(xmlOut, append);
                        VehicleCheckInResType->TargetDistance_isUsed = 1u;
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}TargetDistance>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutReq; type={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutReqType; base type=V2GRequestType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); EVCheckOutStatus, evCheckOutStatusType (1, 1); CheckOutTime, unsignedLong (1, 1);
static int decode_iso20_VehicleCheckOutReqType(exi_bitstream_t* stream, struct iso20_VehicleCheckOutReqType* VehicleCheckOutReqType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 345;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_VehicleCheckOutReqType(VehicleCheckOutReqType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 345:
            // Grammar: ID=345; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=346
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &VehicleCheckOutReqType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 346;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 346:
            // Grammar: ID=346; read/write bits=1; START (EVCheckOutStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVCheckOutStatus, evCheckOutStatusType (string)); next=347
                    if(strlen(xmlOut) + 58 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckOutStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckOutStatus");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 2, &value);
                            if (error == 0)
                            {
                                VehicleCheckOutReqType->EVCheckOutStatus = (iso20_evCheckOutStatusType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_evCheckOutStatusType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_evCheckOutStatusType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 347;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVCheckOutStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 347:
            // Grammar: ID=347; read/write bits=1; START (CheckOutTime)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (CheckOutTime, unsignedLong (nonNegativeInteger)); next=2
                    if(strlen(xmlOut) + 54 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CheckOutTime");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}CheckOutTime");
                    // decode: unsigned long int
                    error = decode_exi_type_uint64(stream, &VehicleCheckOutReqType->CheckOutTime);
                    if (error == 0)
                    {
                        char append[20]; // max length: 19 digits + 0 sign + 1 zero terminator
                        if(strlen(xmlOut) + 20 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                        sprintf(append, "%llu", VehicleCheckOutReqType->CheckOutTime);
                        strcat(xmlOut, ">");
                        strcat(xmlOut, append);
                        grammar_id = 2;
                    }

                    if(strlen(xmlOut) + 54 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CheckOutTime>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutRes; type={urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutResType; base type=V2GResponseType; content type=ELEMENT-ONLY;
//          abstract=False; final=False; derivation=extension;
// Particle: Header, MessageHeaderType (1, 1); ResponseCode, responseCodeType (1, 1); EVSECheckOutStatus, evseCheckOutStatusType (1, 1);
static int decode_iso20_VehicleCheckOutResType(exi_bitstream_t* stream, struct iso20_VehicleCheckOutResType* VehicleCheckOutResType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 348;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_VehicleCheckOutResType(VehicleCheckOutResType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 348:
            // Grammar: ID=348; read/write bits=1; START (Header)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Header, MessageHeaderType (MessageHeaderType)); next=349
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}Header");
                    // decode: element
                    error = decode_iso20_MessageHeaderType(stream, &VehicleCheckOutResType->Header, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 349;
                    }


                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}Header>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 349:
            // Grammar: ID=349; read/write bits=1; START (ResponseCode)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (ResponseCode, responseCodeType (string)); next=350
                    if(strlen(xmlOut) + 51 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 6, &value);
                            if (error == 0)
                            {
                                VehicleCheckOutResType->ResponseCode = (iso20_responseCodeType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_responseCodeType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_responseCodeType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 350;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}ResponseCode>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 350:
            // Grammar: ID=350; read/write bits=1; START (EVSECheckOutStatus)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (EVSECheckOutStatus, evseCheckOutStatusType (string)); next=2
                    if(strlen(xmlOut) + 60 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}EVSECheckOutStatus");
                    xmlPos += strlen("<{urn:iso:std:iso:15118:-20:CommonMessages}EVSECheckOutStatus");
                    // decode: enum
                    error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                    if (error == 0)
                    {
                        if (eventCode == 0)
                        {
                            uint32_t value;
                            error = exi_basetypes_decoder_nbit_uint(stream, 1, &value);
                            if (error == 0)
                            {
                                VehicleCheckOutResType->EVSECheckOutStatus = (iso20_evseCheckOutStatusType)value;
                                if(strlen(xmlOut) + strlen(get_enum_val_iso20_evseCheckOutStatusType_reverse(value)) + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                                strcat(xmlOut, ">");
                                strcat(xmlOut, get_enum_val_iso20_evseCheckOutStatusType_reverse(value));
                            }
                        }
                        else
                        {
                            // second level event is not supported
                            error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                        }
                    }

                    // if nothing went wrong, the error of exi_basetypes_decoder_nbit_uint is evaluated here
                    if (error == 0)
                    {
                        // END Element for simple type
                        error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
                        if (error == 0)
                        {
                            if (eventCode == 0)
                            {
                                grammar_id = 2;
                            }
                            else
                            {
                                error = EXI_ERROR__DEVIANTS_NOT_SUPPORTED;
                            }
                        }
                    }

                    if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}EVSECheckOutStatus>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_CLReqControlModeType(exi_bitstream_t* stream, struct iso20_CLReqControlModeType* CLReqControlModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)CLReqControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlMode; type={urn:iso:std:iso:15118:-20:CommonTypes}CLResControlModeType; base type=; content type=empty;
//          abstract=False; final=False;
static int decode_iso20_CLResControlModeType(exi_bitstream_t* stream, struct iso20_CLResControlModeType* CLResControlModeType, char* xmlOut, size_t xmlOut_size) {
    // Element has no particles, so the function just decodes END Element
    (void)CLResControlModeType;
    uint32_t eventCode;

    int error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
    if (error == 0)
    {
        if (eventCode != 0)
        {
            error = EXI_ERROR__UNKNOWN_EVENT_CODE;
        }
    }

    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}Manifest; type={http://www.w3.org/2000/09/xmldsig#}ManifestType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); Reference, ReferenceType (1, 4) (original max unbounded);
static int decode_iso20_ManifestType(exi_bitstream_t* stream, struct iso20_ManifestType* ManifestType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 351;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_ManifestType(ManifestType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 351:
            // Grammar: ID=351; read/write bits=2; START (Id), START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=353
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &ManifestType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (ManifestType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            ManifestType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, ManifestType->Id.charactersLen, ManifestType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + ManifestType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < ManifestType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(ManifestType->Id.characters[i]))
                                {
                                    ManifestType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, ManifestType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    ManifestType->Id_isUsed = 1u;
                    grammar_id = 353;

                    }
                    break;
                case 1:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=352
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 352;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 352:
            // Grammar: ID=352; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=352
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 352;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 353:
            // Grammar: ID=353; read/write bits=1; START (Reference)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Reference, ReferenceType (ReferenceType)); next=354
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 354;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 354:
            // Grammar: ID=354; read/write bits=2; LOOP (Reference), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: LOOP (Reference, ReferenceType (ReferenceType)); next=354
                    if(strlen(xmlOut) + 45 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}Reference");
                    // decode: element array
                    if (ManifestType->Reference.arrayLen < iso20_ReferenceType_4_ARRAY_SIZE)
                    {

                        error = decode_iso20_ReferenceType(stream, &ManifestType->Reference.array[ManifestType->Reference.arrayLen++], xmlOut, xmlOut_size);
                    }
                    else
                    {
                        // static array not large enough, only iso20_ReferenceType_4_ARRAY_SIZE elements
                        error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;
                    }
                    grammar_id = 354;

                    if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}

// Element: definition=complex; name={http://www.w3.org/2000/09/xmldsig#}SignatureProperties; type={http://www.w3.org/2000/09/xmldsig#}SignaturePropertiesType; base type=; content type=ELEMENT-ONLY;
//          abstract=False; final=False;
// Particle: Id, ID (0, 1); SignatureProperty, SignaturePropertyType (1, 1) (original max unbounded);
static int decode_iso20_SignaturePropertiesType(exi_bitstream_t* stream, struct iso20_SignaturePropertiesType* SignaturePropertiesType, char* xmlOut, size_t xmlOut_size) {
    int grammar_id = 355;
    int done = 0;
    uint32_t eventCode;
    int error;

    init_iso20_SignaturePropertiesType(SignaturePropertiesType);

    while (!done)
    {
        switch (grammar_id)
        {
        case 355:
            // Grammar: ID=355; read/write bits=2; START (Id), START (SignatureProperty)
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (Id, ID (NCName)); next=357
                    if(strlen(xmlOut) + 2 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    strcat(xmlOut, " Id");
                    // decode: string (len, characters) (Attribute)
                    error = exi_basetypes_decoder_uint_16(stream, &SignaturePropertiesType->Id.charactersLen);
                    if (error == 0)
                    {
                        if (SignaturePropertiesType->Id.charactersLen >= 2)
                        {
                            // string tables and table partitions are not supported, so the length has to be decremented by 2
                            SignaturePropertiesType->Id.charactersLen -= 2;
                            error = exi_basetypes_decoder_characters(stream, SignaturePropertiesType->Id.charactersLen, SignaturePropertiesType->Id.characters, iso20_Id_CHARACTER_SIZE);
                            strcat(xmlOut, "=\"");
                            if(strlen(xmlOut) + SignaturePropertiesType->Id.charactersLen + 1 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                            for(int i = 0; i < SignaturePropertiesType->Id.charactersLen; i++) { // check for unprintable characters
                                if(!isprint(SignaturePropertiesType->Id.characters[i]))
                                {
                                    SignaturePropertiesType->Id.characters[i]   = '?';
                                }
                            }
                            strcat(xmlOut, SignaturePropertiesType->Id.characters);
                            strcat(xmlOut, "\"");
                        }
                        else
                        {
                            // the string seems to be in the table, but this is not supported
                            error = EXI_ERROR__STRINGVALUES_NOT_SUPPORTED;
                        }
                    }
                    SignaturePropertiesType->Id_isUsed = 1u;
                    grammar_id = 357;

                    }
                    break;
                case 1:
                    {
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=356
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    // decode: element
                    error = decode_iso20_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 356;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 356:
            // Grammar: ID=356; read/write bits=2; START (SignatureProperty), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 357:
            // Grammar: ID=357; read/write bits=1; START (SignatureProperty)
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=358
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    // decode: element
                    error = decode_iso20_SignaturePropertyType(stream, &SignaturePropertiesType->SignatureProperty, xmlOut, xmlOut_size);
                    if (error == 0)
                    {
                        grammar_id = 358;
                    }


                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 358:
            // Grammar: ID=358; read/write bits=2; START (SignatureProperty), END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 2, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: START (SignatureProperty, SignaturePropertyType (SignaturePropertyType)); next=2
                    if(strlen(xmlOut) + 53 + 2 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    char* xmlPos = &xmlOut[strlen(xmlOut)];
                    if(*(xmlPos - 1) != '>') { strcat(xmlOut, ">"); xmlPos++; }
                    strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    xmlPos += strlen("<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty");
                    // decode: element
                    // This element should not occur a further time, its representation was reduced to a single element
                    error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS;

                    if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
                    bool isClosed = false;
                    while(*xmlPos != '\0' && !isClosed) { if(*xmlPos++ == '>') isClosed = true; }
                    if(!isClosed) {strcat(xmlOut, ">");} // empty element
                    strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                    }
                    break;
                case 1:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        case 2:
            // Grammar: ID=2; read/write bits=1; END Element
            error = exi_basetypes_decoder_nbit_uint(stream, 1, &eventCode);
            if (error == 0)
            {
                switch (eventCode)
                {
                case 0:
                    {
                    // Event: END Element; next=3
                    done = 1;
                    grammar_id = 3;
                    }
                    break;
                default:
                    error = EXI_ERROR__UNKNOWN_EVENT_CODE;
                    break;
                }
            }
            break;
        default:
            error = EXI_ERROR__UNKNOWN_GRAMMAR_ID;
            break;
        }

        if (error)
        {
            done = 1;
        }
    }
    return error;
}


// main function for decoding
int decode_iso20_exiDocument(exi_bitstream_t* stream, struct iso20_exiDocument* exiDoc, char* xmlOut, size_t xmlOut_size) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == 0)
    {
        init_iso20_exiDocument(exiDoc);
        if(strlen(xmlOut) + 38 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
        strcat(xmlOut, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");

        error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
        if (error == 0)
        {
            switch (eventCode)
            {
            case 0:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationReq>");
                error = decode_iso20_AuthorizationReqType(stream, &exiDoc->AuthorizationReq, xmlOut, xmlOut_size);
                exiDoc->AuthorizationReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationReq>");
                break;
            case 1:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationRes>");
                error = decode_iso20_AuthorizationResType(stream, &exiDoc->AuthorizationRes, xmlOut, xmlOut_size);
                exiDoc->AuthorizationRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationRes>");
                break;
            case 2:
                
        if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupReq>");
                error = decode_iso20_AuthorizationSetupReqType(stream, &exiDoc->AuthorizationSetupReq, xmlOut, xmlOut_size);
                exiDoc->AuthorizationSetupReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupReq>");
                break;
            case 3:
                
        if(strlen(xmlOut) + 63 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupRes>");
                error = decode_iso20_AuthorizationSetupResType(stream, &exiDoc->AuthorizationSetupRes, xmlOut, xmlOut_size);
                exiDoc->AuthorizationSetupRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}AuthorizationSetupRes>");
                break;
            case 4:
                
        if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlMode>");
                error = decode_iso20_CLReqControlModeType(stream, &exiDoc->CLReqControlMode, xmlOut, xmlOut_size);
                exiDoc->CLReqControlMode_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}CLReqControlMode>");
                break;
            case 5:
                
        if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonTypes}CLResControlMode>");
                error = decode_iso20_CLResControlModeType(stream, &exiDoc->CLResControlMode, xmlOut, xmlOut_size);
                exiDoc->CLResControlMode_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonTypes}CLResControlMode>");
                break;
            case 6:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                error = decode_iso20_CanonicalizationMethodType(stream, &exiDoc->CanonicalizationMethod, xmlOut, xmlOut_size);
                exiDoc->CanonicalizationMethod_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}CanonicalizationMethod>");
                break;
            case 7:
                
        if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationReq>");
                error = decode_iso20_CertificateInstallationReqType(stream, &exiDoc->CertificateInstallationReq, xmlOut, xmlOut_size);
                exiDoc->CertificateInstallationReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationReq>");
                break;
            case 8:
                
        if(strlen(xmlOut) + 68 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationRes>");
                error = decode_iso20_CertificateInstallationResType(stream, &exiDoc->CertificateInstallationRes, xmlOut, xmlOut_size);
                exiDoc->CertificateInstallationRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}CertificateInstallationRes>");
                break;
            case 9:
                
        if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue>");
                error = decode_iso20_DSAKeyValueType(stream, &exiDoc->DSAKeyValue, xmlOut, xmlOut_size);
                exiDoc->DSAKeyValue_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DSAKeyValue>");
                break;
            case 10:
                
        if(strlen(xmlOut) + 48 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                error = decode_iso20_DigestMethodType(stream, &exiDoc->DigestMethod, xmlOut, xmlOut_size);
                exiDoc->DigestMethod_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestMethod>");
                break;
            case 11:
                
        if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}DigestValue>");
                // simple type! decode_iso20_DigestValue;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}DigestValue>");
                break;
            case 12:
                
        if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyInfo>");
                error = decode_iso20_KeyInfoType(stream, &exiDoc->KeyInfo, xmlOut, xmlOut_size);
                exiDoc->KeyInfo_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyInfo>");
                break;
            case 13:
                
        if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                // simple type! decode_iso20_KeyName;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyName>");
                break;
            case 14:
                
        if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                error = decode_iso20_KeyValueType(stream, &exiDoc->KeyValue, xmlOut, xmlOut_size);
                exiDoc->KeyValue_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}KeyValue>");
                break;
            case 15:
                
        if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Manifest>");
                error = decode_iso20_ManifestType(stream, &exiDoc->Manifest, xmlOut, xmlOut_size);
                exiDoc->Manifest_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Manifest>");
                break;
            case 16:
                
        if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationReq>");
                error = decode_iso20_MeteringConfirmationReqType(stream, &exiDoc->MeteringConfirmationReq, xmlOut, xmlOut_size);
                exiDoc->MeteringConfirmationReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationReq>");
                break;
            case 17:
                
        if(strlen(xmlOut) + 65 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationRes>");
                error = decode_iso20_MeteringConfirmationResType(stream, &exiDoc->MeteringConfirmationRes, xmlOut, xmlOut_size);
                exiDoc->MeteringConfirmationRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}MeteringConfirmationRes>");
                break;
            case 18:
                
        if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                // simple type! decode_iso20_MgmtData;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}MgmtData>");
                break;
            case 19:
                
        if(strlen(xmlOut) + 42 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Object>");
                error = decode_iso20_ObjectType(stream, &exiDoc->Object, xmlOut, xmlOut_size);
                exiDoc->Object_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Object>");
                break;
            case 20:
                
        if(strlen(xmlOut) + 43 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                error = decode_iso20_PGPDataType(stream, &exiDoc->PGPData, xmlOut, xmlOut_size);
                exiDoc->PGPData_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}PGPData>");
                break;
            case 21:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryReq>");
                error = decode_iso20_PowerDeliveryReqType(stream, &exiDoc->PowerDeliveryReq, xmlOut, xmlOut_size);
                exiDoc->PowerDeliveryReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryReq>");
                break;
            case 22:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryRes>");
                error = decode_iso20_PowerDeliveryResType(stream, &exiDoc->PowerDeliveryRes, xmlOut, xmlOut_size);
                exiDoc->PowerDeliveryRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}PowerDeliveryRes>");
                break;
            case 23:
                
        if(strlen(xmlOut) + 47 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue>");
                error = decode_iso20_RSAKeyValueType(stream, &exiDoc->RSAKeyValue, xmlOut, xmlOut_size);
                exiDoc->RSAKeyValue_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RSAKeyValue>");
                break;
            case 24:
                
        if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Reference>");
                error = decode_iso20_ReferenceType(stream, &exiDoc->Reference, xmlOut, xmlOut_size);
                exiDoc->Reference_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Reference>");
                break;
            case 25:
                
        if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                error = decode_iso20_RetrievalMethodType(stream, &exiDoc->RetrievalMethod, xmlOut, xmlOut_size);
                exiDoc->RetrievalMethod_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}RetrievalMethod>");
                break;
            case 26:
                
        if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                error = decode_iso20_SPKIDataType(stream, &exiDoc->SPKIData, xmlOut, xmlOut_size);
                exiDoc->SPKIData_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SPKIData>");
                break;
            case 27:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeReq>");
                error = decode_iso20_ScheduleExchangeReqType(stream, &exiDoc->ScheduleExchangeReq, xmlOut, xmlOut_size);
                exiDoc->ScheduleExchangeReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeReq>");
                break;
            case 28:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeRes>");
                error = decode_iso20_ScheduleExchangeResType(stream, &exiDoc->ScheduleExchangeRes, xmlOut, xmlOut_size);
                exiDoc->ScheduleExchangeRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ScheduleExchangeRes>");
                break;
            case 29:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailReq>");
                error = decode_iso20_ServiceDetailReqType(stream, &exiDoc->ServiceDetailReq, xmlOut, xmlOut_size);
                exiDoc->ServiceDetailReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailReq>");
                break;
            case 30:
                
        if(strlen(xmlOut) + 58 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailRes>");
                error = decode_iso20_ServiceDetailResType(stream, &exiDoc->ServiceDetailRes, xmlOut, xmlOut_size);
                exiDoc->ServiceDetailRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDetailRes>");
                break;
            case 31:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryReq>");
                error = decode_iso20_ServiceDiscoveryReqType(stream, &exiDoc->ServiceDiscoveryReq, xmlOut, xmlOut_size);
                exiDoc->ServiceDiscoveryReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryReq>");
                break;
            case 32:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryRes>");
                error = decode_iso20_ServiceDiscoveryResType(stream, &exiDoc->ServiceDiscoveryRes, xmlOut, xmlOut_size);
                exiDoc->ServiceDiscoveryRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceDiscoveryRes>");
                break;
            case 33:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionReq>");
                error = decode_iso20_ServiceSelectionReqType(stream, &exiDoc->ServiceSelectionReq, xmlOut, xmlOut_size);
                exiDoc->ServiceSelectionReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionReq>");
                break;
            case 34:
                
        if(strlen(xmlOut) + 61 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionRes>");
                error = decode_iso20_ServiceSelectionResType(stream, &exiDoc->ServiceSelectionRes, xmlOut, xmlOut_size);
                exiDoc->ServiceSelectionRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}ServiceSelectionRes>");
                break;
            case 35:
                
        if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupReq>");
                error = decode_iso20_SessionSetupReqType(stream, &exiDoc->SessionSetupReq, xmlOut, xmlOut_size);
                exiDoc->SessionSetupReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupReq>");
                break;
            case 36:
                
        if(strlen(xmlOut) + 57 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupRes>");
                error = decode_iso20_SessionSetupResType(stream, &exiDoc->SessionSetupRes, xmlOut, xmlOut_size);
                exiDoc->SessionSetupRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SessionSetupRes>");
                break;
            case 37:
                
        if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SessionStopReq>");
                error = decode_iso20_SessionStopReqType(stream, &exiDoc->SessionStopReq, xmlOut, xmlOut_size);
                exiDoc->SessionStopReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SessionStopReq>");
                break;
            case 38:
                
        if(strlen(xmlOut) + 56 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SessionStopRes>");
                error = decode_iso20_SessionStopResType(stream, &exiDoc->SessionStopRes, xmlOut, xmlOut_size);
                exiDoc->SessionStopRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SessionStopRes>");
                break;
            case 39:
                
        if(strlen(xmlOut) + 51 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureMethod>");
                error = decode_iso20_SignatureMethodType(stream, &exiDoc->SignatureMethod, xmlOut, xmlOut_size);
                exiDoc->SignatureMethod_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureMethod>");
                break;
            case 40:
                
        if(strlen(xmlOut) + 55 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperties>");
                error = decode_iso20_SignaturePropertiesType(stream, &exiDoc->SignatureProperties, xmlOut, xmlOut_size);
                exiDoc->SignatureProperties_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperties>");
                break;
            case 41:
                
        if(strlen(xmlOut) + 53 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                error = decode_iso20_SignaturePropertyType(stream, &exiDoc->SignatureProperty, xmlOut, xmlOut_size);
                exiDoc->SignatureProperty_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureProperty>");
                break;
            case 42:
                
        if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Signature>");
                error = decode_iso20_SignatureType(stream, &exiDoc->Signature, xmlOut, xmlOut_size);
                exiDoc->Signature_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Signature>");
                break;
            case 43:
                
        if(strlen(xmlOut) + 50 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignatureValue>");
                error = decode_iso20_SignatureValueType(stream, &exiDoc->SignatureValue, xmlOut, xmlOut_size);
                exiDoc->SignatureValue_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignatureValue>");
                break;
            case 44:
                
        if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                error = decode_iso20_SignedInfoType(stream, &exiDoc->SignedInfo, xmlOut, xmlOut_size);
                exiDoc->SignedInfo_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}SignedInfo>");
                break;
            case 45:
                
        if(strlen(xmlOut) + 64 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData>");
                error = decode_iso20_SignedInstallationDataType(stream, &exiDoc->SignedInstallationData, xmlOut, xmlOut_size);
                exiDoc->SignedInstallationData_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SignedInstallationData>");
                break;
            case 46:
                
        if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData>");
                error = decode_iso20_SignedMeteringDataType(stream, &exiDoc->SignedMeteringData, xmlOut, xmlOut_size);
                exiDoc->SignedMeteringData_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}SignedMeteringData>");
                break;
            case 47:
                
        if(strlen(xmlOut) + 45 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transform>");
                error = decode_iso20_TransformType(stream, &exiDoc->Transform, xmlOut, xmlOut_size);
                exiDoc->Transform_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transform>");
                break;
            case 48:
                
        if(strlen(xmlOut) + 46 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                error = decode_iso20_TransformsType(stream, &exiDoc->Transforms, xmlOut, xmlOut_size);
                exiDoc->Transforms_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}Transforms>");
                break;
            case 49:
                
        if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInReq>");
                error = decode_iso20_VehicleCheckInReqType(stream, &exiDoc->VehicleCheckInReq, xmlOut, xmlOut_size);
                exiDoc->VehicleCheckInReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInReq>");
                break;
            case 50:
                
        if(strlen(xmlOut) + 59 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInRes>");
                error = decode_iso20_VehicleCheckInResType(stream, &exiDoc->VehicleCheckInRes, xmlOut, xmlOut_size);
                exiDoc->VehicleCheckInRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckInRes>");
                break;
            case 51:
                
        if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutReq>");
                error = decode_iso20_VehicleCheckOutReqType(stream, &exiDoc->VehicleCheckOutReq, xmlOut, xmlOut_size);
                exiDoc->VehicleCheckOutReq_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutReq>");
                break;
            case 52:
                
        if(strlen(xmlOut) + 60 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutRes>");
                error = decode_iso20_VehicleCheckOutResType(stream, &exiDoc->VehicleCheckOutRes, xmlOut, xmlOut_size);
                exiDoc->VehicleCheckOutRes_isUsed = 1u;
                strcat(xmlOut, "</{urn:iso:std:iso:15118:-20:CommonMessages}VehicleCheckOutRes>");
                break;
            case 53:
                
        if(strlen(xmlOut) + 44 + 3 + 1 > xmlOut_size) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; return error; }
                strcat(xmlOut, "<{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                error = decode_iso20_X509DataType(stream, &exiDoc->X509Data, xmlOut, xmlOut_size);
                exiDoc->X509Data_isUsed = 1u;
                strcat(xmlOut, "</{http://www.w3.org/2000/09/xmldsig#}X509Data>");
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }
        }
    }


    // xmlOut Postprocessing: resolve FQNs
    int FQN_FULL_LENGTH = 50;
    int FQN_SHORT_LENGTH = 5;
    char *prefixList[10][2]; // 10 prefixes max. [0]: shorthand, [1]:fqn
    int prefixCount = 0;
    char* currentXmlPtr = &xmlOut[0];
    size_t posOfPrefixStart;
    size_t prefixSize;
    // create prefix table
    while( (posOfPrefixStart = strcspn(currentXmlPtr, "{")) != strlen(currentXmlPtr) ) {
        currentXmlPtr += posOfPrefixStart + 1;
        prefixSize = strcspn(currentXmlPtr, "}");
        if(prefixSize > FQN_FULL_LENGTH - 1) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
        
        bool hit = false;
        // check if prefix already in list
        for(int i = 0; i < prefixCount; i++)
        {
            if(strncmp(prefixList[i][1], currentXmlPtr, prefixSize) == 0)
            {
                hit = true; break;
            }
        }
        if(!hit) {
            prefixList[prefixCount][0] = malloc(sizeof(*prefixList[prefixCount]) * FQN_SHORT_LENGTH);
            prefixList[prefixCount][1] = malloc(sizeof(*prefixList[prefixCount]) * FQN_FULL_LENGTH);
            strncpy(prefixList[prefixCount][1], currentXmlPtr, prefixSize);
            prefixList[prefixCount][1][prefixSize] = 0;
            sprintf(prefixList[prefixCount][0], "ns%d", prefixCount + 1);
            prefixCount ++;
            if (prefixCount >= 10) { error = EXI_ERROR__ARRAY_OUT_OF_BOUNDS; break; }
        }
        currentXmlPtr += prefixSize;
    }
    char* xmlDup = strdup(xmlOut);
    int elementCount = 0;
    int xmlOutLength = 0;
    for(size_t i = 0; i < strlen(xmlDup); i++)
    {
        if(xmlDup[i] == '{')
        {
            // handle prefix stuff
            i++; // skip '{'
            char fqn[FQN_FULL_LENGTH];
            memset(fqn, 0, FQN_FULL_LENGTH*sizeof(char) );
            for(int j = 0; j < FQN_FULL_LENGTH && i < strlen(xmlDup); j++)
            {
                if(xmlDup[i] == '}') { fqn[j] = 0; break; }
                else { fqn[j] = xmlDup[i]; }
                i++;
            }
            xmlOut[xmlOutLength] = 0;
            for(int k = 0; k < prefixCount; k++) {
                if (strcmp(fqn, prefixList[k][1]) == 0)
                {
                    strcat(xmlOut, prefixList[k][0]);
                    strcat(xmlOut, ":");
                    xmlOutLength += strlen(prefixList[k][0]) + 1;
                    break;
                }
            }
        }
        else
        {
            if(xmlDup[i] == '<') elementCount++;
            if(elementCount == 2 && xmlDup[i] == '>')
            {
                // root element, add namespaces here
                for(int j = 0; j < prefixCount; j++)
                {
                    xmlOut[xmlOutLength] = 0;
                    strcat(xmlOut, " xmlns:");
                    strcat(xmlOut, prefixList[j][0]);
                    strcat(xmlOut, "=\"");
                    strcat(xmlOut, prefixList[j][1]);
                    strcat(xmlOut, "\"");
                    xmlOutLength = strlen(xmlOut);
                }
            }
            xmlOut[xmlOutLength++] = xmlDup[i];
        }
    }
    xmlOut[xmlOutLength] = 0;
    free(xmlDup);
    
    // clean up
    for(int i = 0; i < prefixCount; i++)
    {
        free(prefixList[i][0]);
        free(prefixList[i][1]);
    }

    return error;
}

// main function for decoding fragment
int decode_iso20_exiFragment(exi_bitstream_t* stream, struct iso20_exiFragment* exiFrag, char* xmlOut, size_t xmlOut_size) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso20_exiFragment(exiFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 9, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch (eventCode)
            {
            case 0:
                // AbsolutePriceSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                error = decode_iso20_AbsolutePriceScheduleType(stream, &exiFrag->AbsolutePriceSchedule, xmlOut, xmlOut_size);
                exiFrag->AbsolutePriceSchedule_isUsed = 1u;
                break;
            case 1:
                // AckMaxDelay (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 2:
                // AdditionalSelectedServices (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 3:
                // AdditionalService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 4:
                // AdditionalServicesCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 5:
                // Amount (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 6:
                // AppliesMinimumMaximumCost (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 7:
                // AppliesToEnergyFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 8:
                // AppliesToOverstayFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 9:
                // AppliesToParkingFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 10:
                // AuthorizationReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 11:
                // AuthorizationRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 12:
                // AuthorizationServices (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 13:
                // AuthorizationSetupReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 14:
                // AuthorizationSetupRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 15:
                // AvailableEnergy (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 16:
                // BPT_ChannelSelection (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 17:
                // BPT_DischargedEnergyReadingWh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 18:
                // BPT_InductiveEnergyReadingVARh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 19:
                // BatteryEnergyCapacity (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 20:
                // CLReqControlMode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 21:
                // CLResControlMode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 22:
                // CPSCertificateChain (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 23:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 24:
                // CapacitiveEnergyReadingVARh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 25:
                // CarbonDioxideEmission (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 26:
                // Certificate (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 27:
                // CertificateInstallationReq (urn:iso:std:iso:15118:-20:CommonMessages)
                error = decode_iso20_CertificateInstallationReqType(stream, &exiFrag->CertificateInstallationReq, xmlOut, xmlOut_size);
                exiFrag->CertificateInstallationReq_isUsed = 1u;
                break;
            case 28:
                // CertificateInstallationRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 29:
                // CertificateInstallationService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 30:
                // ChargeProgress (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 31:
                // ChargedEnergyReadingWh (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 32:
                // ChargingComplete (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 33:
                // ChargingSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 34:
                // ChargingSession (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 35:
                // CheckOutTime (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 36:
                // ContractCertificateChain (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 37:
                // CostPerUnit (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 38:
                // Currency (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 39:
                // DHPublicKey (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 40:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 41:
                // DepartureTime (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 42:
                // DepartureTime (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 43:
                // DeviceLocation (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 44:
                // DeviceOffset (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 45:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 46:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 47:
                // DischargingSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 48:
                // DisplayParameters (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 49:
                // Duration (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 50:
                // Dynamic_EVPPTControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 51:
                // Dynamic_SEReqControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 52:
                // Dynamic_SEResControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 53:
                // Dynamic_SMDTControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 54:
                // ECDHCurve (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 55:
                // EIM_AReqAuthorizationMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 56:
                // EIM_ASResAuthorizationMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 57:
                // EMAID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 58:
                // EVAbsolutePriceSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 59:
                // EVCCID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 60:
                // EVCheckInStatus (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 61:
                // EVCheckOutStatus (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 62:
                // EVEnergyOffer (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 63:
                // EVMaximumEnergyRequest (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 64:
                // EVMaximumEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 65:
                // EVMaximumV2XEnergyRequest (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 66:
                // EVMinimumEnergyRequest (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 67:
                // EVMinimumEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 68:
                // EVMinimumV2XEnergyRequest (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 69:
                // EVPowerProfile (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 70:
                // EVPowerProfileEntries (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 71:
                // EVPowerProfileEntry (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 72:
                // EVPowerSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 73:
                // EVPowerScheduleEntries (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 74:
                // EVPowerScheduleEntry (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 75:
                // EVPriceRule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 76:
                // EVPriceRuleStack (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 77:
                // EVPriceRuleStacks (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 78:
                // EVProcessing (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 79:
                // EVSECheckOutStatus (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 80:
                // EVSEID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 81:
                // EVSENotification (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 82:
                // EVSEProcessing (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 83:
                // EVSEStatus (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 84:
                // EVSEStatus (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 85:
                // EVTargetEnergyRequest (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 86:
                // EVTargetEnergyRequest (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 87:
                // EVTerminationCode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 88:
                // EVTerminationExplanation (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 89:
                // EnergyCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 90:
                // EnergyFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 91:
                // EnergyTransferServiceList (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 92:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 93:
                // Exponent (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 94:
                // FreeService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 95:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 96:
                // GenChallenge (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 97:
                // GoToPause (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 98:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 99:
                // Header (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 100:
                // InletHot (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 101:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 102:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 103:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 104:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 105:
                // Language (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 106:
                // ListOfRootCertificateIDs (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 107:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 108:
                // MaximumContractCertificateChains (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 109:
                // MaximumCost (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 110:
                // MaximumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 111:
                // MaximumSupportingPoints (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 112:
                // MeterID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 113:
                // MeterInfo (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 114:
                // MeterInfo (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 115:
                // MeterInfoRequested (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 116:
                // MeterSignature (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 117:
                // MeterStatus (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 118:
                // MeterTimestamp (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 119:
                // MeteringConfirmationReq (urn:iso:std:iso:15118:-20:CommonMessages)
                error = decode_iso20_MeteringConfirmationReqType(stream, &exiFrag->MeteringConfirmationReq, xmlOut, xmlOut_size);
                exiFrag->MeteringConfirmationReq_isUsed = 1u;
                break;
            case 120:
                // MeteringConfirmationRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 121:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 122:
                // MinimumCost (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 123:
                // MinimumSOC (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 124:
                // MinimumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 125:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 126:
                // NotificationMaxDelay (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 127:
                // NumberOfPriceLevels (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 128:
                // OEMProvisioningCertificateChain (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 129:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 130:
                // OccupancyCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 131:
                // OverstayCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 132:
                // OverstayFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 133:
                // OverstayFeePeriod (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 134:
                // OverstayPowerThreshold (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 135:
                // OverstayRule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 136:
                // OverstayRuleDescription (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 137:
                // OverstayRules (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 138:
                // OverstayTimeThreshold (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 139:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 140:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 141:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 142:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 143:
                // Parameter (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 144:
                // ParameterSet (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 145:
                // ParameterSetID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 146:
                // ParkingFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 147:
                // ParkingFeePeriod (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 148:
                // ParkingMethod (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 149:
                // ParkingSpace (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 150:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 151:
                // PnC_AReqAuthorizationMode (urn:iso:std:iso:15118:-20:CommonMessages)
                error = decode_iso20_PnC_AReqAuthorizationModeType(stream, &exiFrag->PnC_AReqAuthorizationMode, xmlOut, xmlOut_size);
                exiFrag->PnC_AReqAuthorizationMode_isUsed = 1u;
                break;
            case 152:
                // PnC_ASResAuthorizationMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 153:
                // Power (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 154:
                // PowerDeliveryReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 155:
                // PowerDeliveryRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 156:
                // PowerRangeStart (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 157:
                // PowerSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 158:
                // PowerScheduleEntries (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 159:
                // PowerScheduleEntry (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 160:
                // PowerTolerance (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 161:
                // PowerToleranceAcceptance (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 162:
                // Power_L2 (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 163:
                // Power_L3 (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 164:
                // PresentSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 165:
                // PriceAlgorithm (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 166:
                // PriceLevel (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 167:
                // PriceLevelSchedule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 168:
                // PriceLevelScheduleEntries (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 169:
                // PriceLevelScheduleEntry (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 170:
                // PriceRule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 171:
                // PriceRuleStack (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 172:
                // PriceRuleStacks (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 173:
                // PriceScheduleDescription (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 174:
                // PriceScheduleID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 175:
                // PrioritizedEMAIDs (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 176:
                // ProviderID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 177:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 178:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 179:
                // Receipt (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 180:
                // Receipt (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 181:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 182:
                // RemainingContractCertificateChains (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 183:
                // RemainingTimeToMaximumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 184:
                // RemainingTimeToMinimumSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 185:
                // RemainingTimeToTargetSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 186:
                // RenewableGenerationPercentage (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 187:
                // ResponseCode (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 188:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 189:
                // RootCertificateID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 190:
                // SECP521_EncryptedPrivateKey (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 191:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 192:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 193:
                // ScheduleExchangeReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 194:
                // ScheduleExchangeRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 195:
                // ScheduleTuple (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 196:
                // ScheduleTupleID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 197:
                // Scheduled_EVPPTControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 198:
                // Scheduled_SEReqControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 199:
                // Scheduled_SEResControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 200:
                // Scheduled_SMDTControlMode (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 201:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 202:
                // SelectedAuthorizationService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 203:
                // SelectedEnergyTransferService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 204:
                // SelectedScheduleTupleID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 205:
                // SelectedService (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 206:
                // SelectedVASList (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 207:
                // Service (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 208:
                // ServiceDetailReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 209:
                // ServiceDetailRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 210:
                // ServiceDiscoveryReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 211:
                // ServiceDiscoveryRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 212:
                // ServiceFee (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 213:
                // ServiceID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 214:
                // ServiceName (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 215:
                // ServiceParameterList (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 216:
                // ServiceRenegotiationSupported (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 217:
                // ServiceSelectionReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 218:
                // ServiceSelectionRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 219:
                // SessionID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 220:
                // SessionID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 221:
                // SessionSetupReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 222:
                // SessionSetupRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 223:
                // SessionStopReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 224:
                // SessionStopRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 225:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 226:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 227:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 228:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 229:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 230:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignedInfoType(stream, &exiFrag->SignedInfo, xmlOut, xmlOut_size);
                exiFrag->SignedInfo_isUsed = 1u;
                break;
            case 231:
                // SignedInstallationData (urn:iso:std:iso:15118:-20:CommonMessages)
                error = decode_iso20_SignedInstallationDataType(stream, &exiFrag->SignedInstallationData, xmlOut, xmlOut_size);
                exiFrag->SignedInstallationData_isUsed = 1u;
                break;
            case 232:
                // SignedMeteringData (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 233:
                // StartTime (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 234:
                // SubCertificates (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 235:
                // SupportedProviders (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 236:
                // SupportedServiceIDs (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 237:
                // TPM_EncryptedPrivateKey (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 238:
                // TargetDistance (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 239:
                // TargetOffsetX (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 240:
                // TargetOffsetY (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 241:
                // TargetSOC (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 242:
                // TargetSOC (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 243:
                // TaxCosts (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 244:
                // TaxIncludedInPrice (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 245:
                // TaxRate (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 246:
                // TaxRule (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 247:
                // TaxRuleID (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 248:
                // TaxRuleID (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 249:
                // TaxRuleName (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 250:
                // TaxRules (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 251:
                // TimeAnchor (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 252:
                // TimeAnchor (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 253:
                // TimeStamp (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 254:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 255:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 256:
                // VASList (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 257:
                // Value (urn:iso:std:iso:15118:-20:CommonTypes)
                break;
            case 258:
                // VehicleCheckInReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 259:
                // VehicleCheckInRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 260:
                // VehicleCheckOutReq (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 261:
                // VehicleCheckOutRes (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 262:
                // VehicleFrame (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 263:
                // VehicleTravel (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 264:
                // X448_EncryptedPrivateKey (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 265:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 266:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 267:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 268:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 269:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 270:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 271:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 272:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 273:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 274:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 275:
                // boolValue (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 276:
                // byteValue (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 277:
                // finiteString (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 278:
                // intValue (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 279:
                // rationalNumber (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            case 280:
                // shortValue (urn:iso:std:iso:15118:-20:CommonMessages)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 9, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 282)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}

// main function for decoding xmldsig fragment
int decode_iso20_xmldsigFragment(exi_bitstream_t* stream, struct iso20_xmldsigFragment* xmldsigFrag, char* xmlOut, size_t xmlOut_size) {
    uint32_t eventCode;
    int error = exi_header_read_and_check(stream);

    if (error == EXI_ERROR__NO_ERROR)
    {
        init_iso20_xmldsigFragment(xmldsigFrag);

        error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
        if (error == EXI_ERROR__NO_ERROR)
        {
            error = EXI_ERROR__NOT_IMPLEMENTED_YET;
            switch (eventCode)
            {
            case 0:
                // CanonicalizationMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_CanonicalizationMethodType(stream, &xmldsigFrag->CanonicalizationMethod, xmlOut, xmlOut_size);
                xmldsigFrag->CanonicalizationMethod_isUsed = 1u;
                break;
            case 1:
                // DSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_DSAKeyValueType(stream, &xmldsigFrag->DSAKeyValue, xmlOut, xmlOut_size);
                xmldsigFrag->DSAKeyValue_isUsed = 1u;
                break;
            case 2:
                // DigestMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_DigestMethodType(stream, &xmldsigFrag->DigestMethod, xmlOut, xmlOut_size);
                xmldsigFrag->DigestMethod_isUsed = 1u;
                break;
            case 3:
                // DigestValue (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 4:
                // Exponent (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 5:
                // G (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 6:
                // HMACOutputLength (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 7:
                // J (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 8:
                // KeyInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_KeyInfoType(stream, &xmldsigFrag->KeyInfo, xmlOut, xmlOut_size);
                xmldsigFrag->KeyInfo_isUsed = 1u;
                break;
            case 9:
                // KeyName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 10:
                // KeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_KeyValueType(stream, &xmldsigFrag->KeyValue, xmlOut, xmlOut_size);
                xmldsigFrag->KeyValue_isUsed = 1u;
                break;
            case 11:
                // Manifest (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ManifestType(stream, &xmldsigFrag->Manifest, xmlOut, xmlOut_size);
                xmldsigFrag->Manifest_isUsed = 1u;
                break;
            case 12:
                // MgmtData (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 13:
                // Modulus (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 14:
                // Object (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ObjectType(stream, &xmldsigFrag->Object, xmlOut, xmlOut_size);
                xmldsigFrag->Object_isUsed = 1u;
                break;
            case 15:
                // P (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 16:
                // PGPData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_PGPDataType(stream, &xmldsigFrag->PGPData, xmlOut, xmlOut_size);
                xmldsigFrag->PGPData_isUsed = 1u;
                break;
            case 17:
                // PGPKeyID (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 18:
                // PGPKeyPacket (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 19:
                // PgenCounter (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 20:
                // Q (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 21:
                // RSAKeyValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_RSAKeyValueType(stream, &xmldsigFrag->RSAKeyValue, xmlOut, xmlOut_size);
                xmldsigFrag->RSAKeyValue_isUsed = 1u;
                break;
            case 22:
                // Reference (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_ReferenceType(stream, &xmldsigFrag->Reference, xmlOut, xmlOut_size);
                xmldsigFrag->Reference_isUsed = 1u;
                break;
            case 23:
                // RetrievalMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_RetrievalMethodType(stream, &xmldsigFrag->RetrievalMethod, xmlOut, xmlOut_size);
                xmldsigFrag->RetrievalMethod_isUsed = 1u;
                break;
            case 24:
                // SPKIData (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SPKIDataType(stream, &xmldsigFrag->SPKIData, xmlOut, xmlOut_size);
                xmldsigFrag->SPKIData_isUsed = 1u;
                break;
            case 25:
                // SPKISexp (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 26:
                // Seed (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 27:
                // Signature (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignatureType(stream, &xmldsigFrag->Signature, xmlOut, xmlOut_size);
                xmldsigFrag->Signature_isUsed = 1u;
                break;
            case 28:
                // SignatureMethod (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignatureMethodType(stream, &xmldsigFrag->SignatureMethod, xmlOut, xmlOut_size);
                xmldsigFrag->SignatureMethod_isUsed = 1u;
                break;
            case 29:
                // SignatureProperties (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignaturePropertiesType(stream, &xmldsigFrag->SignatureProperties, xmlOut, xmlOut_size);
                xmldsigFrag->SignatureProperties_isUsed = 1u;
                break;
            case 30:
                // SignatureProperty (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignaturePropertyType(stream, &xmldsigFrag->SignatureProperty, xmlOut, xmlOut_size);
                xmldsigFrag->SignatureProperty_isUsed = 1u;
                break;
            case 31:
                // SignatureValue (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignatureValueType(stream, &xmldsigFrag->SignatureValue, xmlOut, xmlOut_size);
                xmldsigFrag->SignatureValue_isUsed = 1u;
                break;
            case 32:
                // SignedInfo (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_SignedInfoType(stream, &xmldsigFrag->SignedInfo, xmlOut, xmlOut_size);
                xmldsigFrag->SignedInfo_isUsed = 1u;
                break;
            case 33:
                // Transform (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_TransformType(stream, &xmldsigFrag->Transform, xmlOut, xmlOut_size);
                xmldsigFrag->Transform_isUsed = 1u;
                break;
            case 34:
                // Transforms (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_TransformsType(stream, &xmldsigFrag->Transforms, xmlOut, xmlOut_size);
                xmldsigFrag->Transforms_isUsed = 1u;
                break;
            case 35:
                // X509CRL (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 36:
                // X509Certificate (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 37:
                // X509Data (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_X509DataType(stream, &xmldsigFrag->X509Data, xmlOut, xmlOut_size);
                xmldsigFrag->X509Data_isUsed = 1u;
                break;
            case 38:
                // X509IssuerName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 39:
                // X509IssuerSerial (http://www.w3.org/2000/09/xmldsig#)
                error = decode_iso20_X509IssuerSerialType(stream, &xmldsigFrag->X509IssuerSerial, xmlOut, xmlOut_size);
                xmldsigFrag->X509IssuerSerial_isUsed = 1u;
                break;
            case 40:
                // X509SKI (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 41:
                // X509SerialNumber (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 42:
                // X509SubjectName (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 43:
                // XPath (http://www.w3.org/2000/09/xmldsig#)
                break;
            case 44:
                // Y (http://www.w3.org/2000/09/xmldsig#)
                break;
            default:
                error = EXI_ERROR__UNSUPPORTED_SUB_EVENT;
                break;
            }

            if (error == EXI_ERROR__NO_ERROR)
            {
                // End Fragment
                error = exi_basetypes_decoder_nbit_uint(stream, 6, &eventCode);
                if (error == EXI_ERROR__NO_ERROR)
                {
                    if (eventCode != 46)
                    {
                        error = EXI_ERROR__INCORRECT_END_FRAGMENT_VALUE;
                    }
                }
            }
        }
    }

    return error;
}


